## RISC-V架构介绍

### 寄存器说明

关于RISC-V 寄存器说明的详细内容，可以参阅。

我们的实验基于 RISC-V 64 位架构。与大家在计算机组成原理实验课中接触到的RISC-V 32位架构不同，在 RISC-V 64 架构中，寄存器和指针的宽度都是 64 位。

RISC-V 64 位架构总共有 32 个通用寄存器(General-purpose   register，简称GPR)和若干控制状态寄存器（Control Status Register，简称CSR） 。通用寄存器用于存储和操作通用数据,它们是处理器中用于执行各种计算和数据传输操作的主要寄存器。

CSR是一种特殊的寄存器，由处理器硬件定义和管理。它通常包含一组位字段（bits），每个位字段代表不同的状态或控制标志。这些位字段可以存储和读取处理器的运行状态、中断状态、特权级别、运行模式等信息。
CSR的具体功能和位字段的含义会因不同的处理器体系结构而异。RISC-V 架构中有一组约定的CSR，用于管理和控制处理器的运行状态，如以下示例：

    
- **sstatus**: 包含处理器的运行状态和特权级别信息。
    
- **sie**: 包含处理器中断使能的标志位。
    
- **scause**：用于存储最近的中断或异常原因。
    
- **sepc**：存储异常程序计数器，指向中断或异常处理程序的地址。

通过读取和写入CSR的位字段，软件可以查询和修改处理器的运行状态和控制标志。例如，通过将位字段设置为特定的值，可以启用或禁用中断，修改特权级别，触发异常处理等。在 RISC-V 架构中，只能使用控制状态寄存器指令（csrr、csrw 等）访问和修改 CSR。控制状态寄存器指令的使用与特权级相关，相关的内容将在后续的实验中介绍。

CSR在处理器的内部实现中起着重要的作用，它提供了一种机制来管理和控制处理器的行为。同时，CSR也是处理器与操作系统、编译器等软件之间的接口，用于进行状态传递和控制。

### 应用程序二进制接口

应用程序二进制接口（Application Binary interface，简称 ABI）定义了应用程序二进制代码中相关数据结构和函数模块的格式及其访问方式。这个约定是人为的，硬件上并不强制这些内容，自成体系的软件可以不遵循部分或者全部 ABI。为了和编译器以及其他的库配合，我们应该在写汇编代码时尽量遵循约定。ABI 包含但不限于以下内容：

    
- 处理器基础数据类型的大小。布局和对齐要求。
    
- 寄存器使用约定。约定通用寄存器的使用方法、别名等。
    
- 函数调用约定。约定参数调用、结果返回、栈的使用。
    
- 可执行文件格式。
    
- 系统调用约定。

下面主要介绍寄存器使用约定。

#### 通用寄存器使用约定

RISC-V 中的通用寄存器分为两类，一类在函数调用的过程中不保留，称为**临时寄存器**。另一类寄存器则对应地称为 **保存寄存器**。表罗列出了寄存器的 RISC-V 应用程序二进制接口（ABI）名称和它们在函数调用中是否保留的规定。除了保存寄存器之外，调用者需要保证用于存储返回地址的寄存器( ra )和存储栈指针的寄存器( sp )在函数调用前后保持不变。

简而言之，如果某次函数调用需要改变保存寄存器的值，就需要采用适当的措施在退出函数时恢复保存寄存器的值。在第 
节中将结合相应的汇编代码对寄存器使用约定和函数调用约定做进一步的介绍。

<!-- Table: RISC-V 通用寄存器{tab:registers -->


## RISC-V汇编介绍

### RISC-V汇编语言

关于RISC-V汇编语言的详细内容，可以参阅。

在此，我们讲述一些C语言和RISC-V语言的对应关系，便于大家后面编写汇编代码。汇编语言可以理解为机器语言的直接翻译，是对于处理器的最直接的操作。RISC类型的处理器使用load/store类指令将变量在内存与寄存器间进行转移，除了这类指令外，其他指令都是在寄存器与寄存器之间的操作。

为了便于大家理解汇编如何编写，下面我们演示一下，我们所熟悉的C语言是如何被转换为汇编的。作为例子，这里选用一个简单的选择排序代码来作为演示。为了演示到所有的情况，我们有意使用了循环、函数调用等元素。

codes/riscv-example.c

那么，上面这段C代码对应的汇编代码是什么样呢？

首先，GCC有一个特性：所有的循环，都会换成`do{`while();}的形式来实现。
例如，GCC翻译出来的循环用C语言形象地表示是这个样子的：

```bash
for (int i = 0; i < n; ++i) {
   // ...
}
// 会被翻译成
int i = 0;
if (i >= n) goto END;
do {
   // ...
   ++i;
} while (i < n);
END:
// 进一步被翻译成
int i = 0;
goto L2;
L1:
  // ...
  ++i;
L2:
  if (!(i<n)) goto END;
  goto L1;
END:

```

函数调用会将第一个参数放在a0寄存器，第二个参数放在a1寄存器，依次类推，最后用call指令调用相应的函数。

```bash
ld a1, -24(s0); # 假设第二个参数位于-24(s0)
ld a0, -20(s0); # 假设第二个参数位于-20(s0)
call func # 相当于func(a0,a1);

```

进入函数时，先分配栈空间。分配方法就是将栈指针减去需要的空间字节数（栈是向下增长的）。sp到sp-X这X字节的空间就是当前函数运行所需的栈空间。将保存寄存器和返回地址寄存器( ra )的值存储在这部分栈空间中，退出时恢复。对于调用者来说，保存寄存器和返回地址寄存器( ra )的值在函数调用前后是不变的。栈指针( sp )的值也会在函数退出时进行恢复。此外，如果函数中使用了较多的局部变量，也会在栈空间上多开辟一部分空间用于存储局部变量。在内核编程中，内核栈的大小通常是有限的，如果函数中使用了大量的局部数据，很可能会发生栈溢出，覆盖了其他的内存区域，而引发奇怪的问题。

```bash
func:
  addi sp,sp,-32
  sd   s0, 0(sp)
  sd   s1, 8(sp)
  sd   ra, 16(sp)
  # ...
  ld   ra, 16(sp)
  ld   s1, 8(sp)
  ld   s0, 0(sp)
  addi sp,sp,32
  jr ra

```

一般汇编里加载地址有两个常用方式：绝对地址加载和PC相对加载。

直接加载绝对地址的示例如下：

```bash
.section .text
.globl _start
_start:
        lui a0,       
        addi a0, a0,  
        jal ra, puts
2:      j 2b

.section .rodata
msg:
        .string "Hello World"

```

PC相对的地址加载方式如下：

```bash
.section .text
.globl _start
_start:
1:      auipc a0,     
        addi  a0, a0, 
        jal ra, puts
2:      j 2b

.section .rodata
msg:
        .string "Hello World"

```

下面是C编译器翻译出来的代码对应的RISC-V汇编代码。
codes/riscv-example.s

### RISC-V常用汇编指令

RISC-V的算术、逻辑运算等指令用法可以参考一书。
RISC常用伪指令如表和表所示。伪指令是为了编写汇编方便所准备的指令，会被汇编器自动翻译成多条汇编指令。

<!-- Table: RISC-V 伪指令{riscv-spec -->

<!-- Table: RISC-V 伪指令(续){riscv-spec -->

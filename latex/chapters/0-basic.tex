\chapter{准备知识}

\section{引言}
操作系统是计算机系统的重要系统软件，也是计算机专业教学中的一个重要内容。这门课程内容复杂且抽象，涉及到从体系结构到应用软件等多个方面的知识。我们认为，掌握操作系统原理的最好方法，就是自己编写一个操作系统。对于多数同学来说，知识如果不去使用，就很难理解得深，也很容易忘掉。因此在这门课中，我们希望同学们通过自己的努力，能够从头实现一个自己的操作系统，并在实现的过程中不断加深对操作系统的理解，而不是只停留在理论课的“纸上谈兵”。

通过该实验课，大家将由浅入深，从操作系统的引导到操作系统复杂的内部实现，一步一步，深刻理解操作系统中进程的管理、中断的处理、内存的管理、文件系统等相关知识，并将其实现出来。我们衷心希望，每个选修完这门课的同学以后都能自豪地说：“我自己实现过一个完整的操作系统”。

最后，如果在实验的过程中发现有什么问题，希望大家积极和老师、助教反映，提出自己的意见。对于学有余力的同学，非常欢迎加入我们，一起将国科大的操作系统实验课做得更好。接下来，让我们从环境搭建开始，一步一步实现我们的操作系统UCAS-OS吧！




\section{开发环境快速搭建}

Project 0 的任务主要是为后面的实验准备环境和工具。
我们会涉及到作为开发环境的Linux操作系统、交叉编译器 \texttt{riscv-gcc}、虚拟机软件 \texttt{QEMU}，以及基于 FPGA 的 RISC-V 开发板。
我们的开发语言以 \texttt{C} 语言为主，但绕不开一些基本的 RISC-V 指令集汇编语言，调试工具除了使用 \texttt{printf} 之类用于打印的函数外，一定要熟悉 \texttt{gdb} 的断点与寄存器查看的功能，整个工程要通过 \texttt{git} 工具进行管理等等。
如果这些工具已经把你弄得有点晕头转向，那么一定要花点时间耐心地看看 Project 0 的相关知识，因为这些工具是操作系统开发的标准配置，特别是调试工具等。
如果不能用好工具，开发操作系统可能会寸步难行。

看到这么多要学的工具用法和准备知识，也不要害怕，边学边用是我们的法宝。让我们开始吧。

为了让大家快速完成开发环境的搭建，我们已经将开发所需的环境集成到我们所给的 VirtualBox 虚拟机镜像中，
同学们只需要安装完成 VirtualBox，导入我们所给的镜像，并简单配置一下即可。
当然，我们也在附录中给出了手动配置环境的具体流程，感兴趣的同学可以了解一下。

关于环境搭建所需的工具，我们已经拷贝到了发给大家的SD卡中。
此外，我们也将工具上传到了百度云中通过网盘分享的文件：OS研讨课2025，链接:\url{https://pan.baidu.com/s/1uJBhWIF3f_Io1YKPmlBK0g} 提取码: ucas 。


\subsection{Windows实验环境搭建}
这一节主要讲解Windows下环境的搭建，搭建实验环境所需文件及描述见表 \ref{tab:windows-evn-files}。

\begin{table}[hbtp]
\begin{tabularx}{\textwidth}{p{6cm}XX}
\toprule
文件名称                                                        & 说明                          & 对应网盘目录              \\ \midrule
VirtualBox\_7.1.10\_169112\_Win.exe                            & VirtualBox windows安装包       & Windows\_virtualbox \\
UCAS\_OS\_2025.ova                       & 为RISC-V版本实验准备的VirtualBox虚拟机镜像 & 已有交叉编译环境的镜像         \\
Oracle\_VM\_VirtualBox\_Extension\_Pack-7.1.10.vbox-extpack & VirtualBox拓展包               & Windows\_virtualbox \\ \bottomrule
\end{tabularx}
\caption{Windows实验环境所需文件\label{tab:windows-evn-files}}
\end{table}

首先，需要安装VirtualBox虚拟机。右键打开菜单，选择\textbf{以管理员身份运行}。按照安装向导的提示一步步完成安装即可。完成后打开虚拟机软件（如图 \ref{fig:vbox-install} 所示）。

完成VirtualBox的安装后，需要再进一步安装VirtualBox的扩展包。VirtualBox扩展包主要用于增强VirtualBox的USB 2.0、USB 3.0、摄像头等设备的支持，可以提高部分设备的性能。安装方法为：运行VirtualBox->管理->全局设定->扩展->选择扩展包目录->安装->重启。过程如图\ref{fig:vbox-install2}所示。

\begin{figure}[htbp]
	\centering
	\subfigure[]{\includegraphics[width=7cm]{vbox-install1}}
	\subfigure[]{\includegraphics[width=7cm]{vbox-install2}}
	\caption{安装Virtual Box}\label{fig:vbox-install}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=8cm]{vbox-install3}
	\caption{安装Virtual Box}\label{fig:vbox-install2}
\end{figure}

\begin{note}
VirtualBox 最早由 Sun Microsystems 公司开发并以 GPL 协议开源。在 Oracle 收购 Sun 后
，VirtualBox 主体部分仍以 GPL 协议开源的，但一些增强功能以采用 PUEL 协议的 Extention Pack 的方式提供。
该协议\cite{oracle-vrtualbox-faq}规定，可以出于个人和教育目的免费使用 Extention Pack。商业用途需付费购买许可。
\end{note}

之后，请按照 \ref{subsec:import_vbox} 小节的说明，将虚拟机导入，
导入后就可以使用我们预先制作好的 Ubuntu 虚拟机中的环境，开始操作系统实验了。



 \subsection{导入虚拟机\label{subsec:import_vbox}}
VirtualBox 导入虚拟机的方式在不同平台上都是相同的，这里以 Windows 上导入虚拟机镜像为例。
过程如图 \ref{fig:vbox-import} 所示。RISC-V 版本实验环境采用 Ubuntu Server 20.04，文件名为 \texttt{UCAS\_OS\_2024.ova}。
请注意选择正确的虚拟机镜像进行导入。

我们预先配置好的镜像，用户名是\texttt{stu},密码是\texttt{123456}。

\begin{figure}[htbp]
    \centering
    \subfigure[选择导入虚拟电脑]{\includegraphics[width=4.5cm]{vbox-import1}}
    \subfigure[选择导入Ubuntu]{\includegraphics[width=4.55cm]{vbox-import2}}
    \subfigure[点击导入]{\includegraphics[width=4.5cm]{vbox-import3}}
    \caption{导入虚拟机}\label{fig:vbox-import}
\end{figure} 

\subsection{Linux实验环境搭建\label{subsec:linux_env}}
建议在Linux下也安装VirtualBox，然后按照 \ref{subsec:import_vbox} 小节的内容直接导入我们准备好的虚拟机。我们准备的虚拟机上环境都已经配齐了。

当然，如果你不喜欢虚拟机，我们也欢迎大家直接在Linux系统上配置整套环境。接下来，我们会介绍一下如何在Linux下自行构建交叉编译工具链，并配置相关开发环境。这也是我们为虚拟机镜像配置相关环境的过程。

首先，安装minicom。一般直接使用包管理器安装即可。
\begin{lstlisting}[language=bash]
在Ubuntu/Debian/Deepin等系统下
$ sudo apt-get install minicom
在Fedora/CentOS等系统下
$ sudo yum install minicom
\end{lstlisting}

接着，安装构建交叉编译工具链所需依赖。
\begin{lstlisting}[language=bash]
在Ubuntu/Debian/Deepin等系统下
$ sudo apt-get install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev
$ sudo apt-get install libgmp-dev gawk build-essential bison flex texinfo gperf 
$ sudo apt-get install libtool patchutils bc zlib1g-dev libexpat-dev
在Fedora/CentOS等系统下
$ sudo yum install autoconf automake libmpc-devel mpfr-devel gmp-devel gawk  bison 
$ sudo yum install flex texinfo patchutils gcc gcc-c++ zlib-devel expat-devel

\end{lstlisting}

最后，解压我们提供的riscv-gnu-toolchain.zip,构建交叉编译工具链。
\begin{lstlisting}[language=bash]
在解压出来riscv-gnu-toolchain同级目录下建立一个用于构建的目录
$ mkdir rv64-gnu-tools
进入新建立的目录
$ cd rv64-gnu-tools
构建并安装到/opt/riscv64-linux
$ ./configure --prefix=/opt/riscv64-linux
$ sudo make linux -j4
注意，-j4代表4线程编译，你的机器几个核就设置使用几个线程，请自行调节该参数。
\end{lstlisting}

为了方便，可以将为工具链配置环境变量。
\begin{lstlisting}[language=bash]
打开文件.bashrc
$ vi ~/.bashrc
按i进入编辑模式，在文件末尾添加语句：export PATH=/opt/riscv64-linux/bin:$PATH
按ESC退出编辑模式，按:wq保存退出vi。

导入环境变量
$ source ~/.bashrc

\end{lstlisting}

测试一下，应该就可以找到交叉编译工具链了。
\begin{lstlisting}[language=bash]
$ riscv64-unknown-linux-gnu-gcc -v
Using built-in specs.
COLLECT_GCC=riscv64-unknown-linux-gnu-gcc
COLLECT_LTO_WRAPPER=/opt/riscv64-linux/libexec/gcc/riscv64-unknown-linux-gnu/
8.3.0/lto-wrapper
Target: riscv64-unknown-linux-gnu
Configured with: /home/wangluming/os_course/riscv-gnu-toolchain/riscv-gcc/configure --target=riscv64-unknown-linux-gnu --prefix=/opt/riscv64-linux --with-sysroot=/opt/riscv64-linux/sysroot --with-system-zlib --enable-shared --enable-tls --enable-languages=c,c++,fortran --disable-libmudflap --disable-libssp --disable-libquadmath --disable-nls --disable-bootstrap --src=/home/wangluming/os_course/riscv-gnu-toolchain/riscv-gcc --enable-checking=yes --disable-multilib --with-abi=lp64d --with-arch=rv64imafdc --with-tune=rocket 'CFLAGS_FOR_TARGET=-O2-mcmodel=medlow' 'CXXFLAGS_FOR_TARGET=-O2  -mcmodel=medlow'
Thread model: posix
gcc version 8.3.0 (GCC)

\end{lstlisting}

RISC-V的交叉编译工具链的编译在有些时候会依赖某些库的特定版本。如果构建过程中发生编译错误，可能是因为库版本不合适，具体哪个库有问题不好定位。笔者曾在CentOS 7和Ubuntu 20.04上测试，这两个发行版自带的库版本是可以正常编译的。webIDE上的环境是Ubuntu的，所以可以正常安装。

除了安装交叉编译工具链之外，为了方便调试，还推荐大家使用QEMU模拟器，安装的方法类似，使用我们提供的安装包编译QEMU和U-boot即可。需要注意的是，我们在start-code中给出了Makefile，里面指定了默认的QEMU路径，需要大家在安装的时候也构造出相同的路径，或者根据自己的喜好，把Makefile里面的默认路径改掉。


\section{开发板及工具介绍}
实验采用XILINX PYNQ Z2开发板\cite{xilinx-pynq}，开发板的处理单元由ARM核部分和FPGA部分构成。在开发板上电时，首先由ARM核启动板卡初始化相关程序，其根据板卡上标有SW1的开关的状态，将RISC-V处理器核烧入FPGA。之后，RISC-V核加载我们编写的程序。

实验中使用的RISC-V核为升级后的双核Nutshell。NutShell为国科大第一届“一生一芯”计划的产出，已在Github等网站上开源，我们升级并维护的版本为\href{https://github.com/DASICS-ICT/NutShell-DASICS}{NutShell-DASICS}，感兴趣的同学可以自己搜索了解。在PYNQ板卡上，时钟主频为50MHz。后续的实验中可以通过不同的命令启动单/双核 Nutshell。 由于资源限制，我们提供的RISC-V核心均没有浮点模块。 

\subsection{开发板的启动}
我们使用的开发板如图\ref{pynq-z2}所示。请按照图示的顺序配置并使用开发板。

\begin{enumerate}

\item \textbf{将开发板设置为SD卡启动}

图示中1处的跳线设置的是开发板的启动方式。PYNQ-Z2支持从SD卡、QSPI和JTAG启动。我们将跳线插到最左侧，选择用SD卡启动。请保证跳线跳在了最左侧的两个针脚上面。

\item \textbf{设置电源选项} 

图示中的2处的跳线设置的是开发板的供电方式。PYNQ支持外部电源供电和Micro-USB接口供电。我们把跳线跳在USB这个选项上（靠上侧的两个针脚），用Micro USB接口直接供电。

\item \textbf{插入SD卡} 

插入根据\ref{subsec:make-sd-card}节所述制作好的SD卡。注意插入方向，不要插反。

\item \textbf{插入Micro-USB数据线} 

Micro-USB线一端连接图示4位置，一端连接笔记本的USB口。PYNQ-Z2开发板和电脑通过Micro-USB线连接。连接好后，Micro-USB线同时承担供电和通信的功能。

% \item \textbf{设置SW1开关} 拨动图示7位置处的SW1开关到靠近板卡边缘一侧。该开关用于切换NutShell和Rocket。开关拨动到靠近板卡边缘一侧是NutShell。

\item \textbf{打开电源开关} 

打开图示5位置的电源开关，开发板上红色指示灯亮起，之后绿色的Done信号灯亮起。之后代表NutShell的LED灯LD0亮起1秒后熄灭，随后Done信号灯重新亮起，表明开发板已开始工作。

\item \textbf{RESET键}

图示6位置为RESET按键，板子上标记SRST字样。按下该按键会让开发板重置。如果需要开发板从加电开始重新再执行一遍，可以按该按键。

\end{enumerate}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=13cm]{pynq-z2}
	\caption{PYNQ Z2开发板}\label{pynq-z2}
\end{figure}

\subsection{minicom的配置}

在主机端，我们使用minicom和开发板通信。启动minicom的方法为：

\begin{lstlisting}[language=bash]
$ sudo minicom -s
\end{lstlisting}

需要把Serial port setup中的Serial Device设为/dev/ttyUSB1。同时，确保Bps/Par/Bits项的值为115200。过程如图\ref{fig:minicom}所示。\textbf{注意：与图中不同，Serial Device需要设置为/dev/ttyUSB1}。

\begin{figure}[htbp]
	\centering
	\subfigure[设置串口选项]{\includegraphics[width=5cm]{minicom1}}
	\subfigure[设置为\textbf{/dev/ttyUSB1}(和图中不同)]{\includegraphics[width=5cm]{minicom2}}
	\subfigure[保存设置]{\includegraphics[width=5cm]{minicom3}}
	\subfigure[退出]{\includegraphics[width=5cm]{minicom4}}
	\caption{minicom界面}\label{fig:minicom}
\end{figure}

将SD卡插入开发板（确保第一个分区中包含了BOOT.BIN等文件），在连接并启动开发板并打开minicom后，按下重置键（SRST）。
如果设置正确，可以看到终端输出RISC-V启动环境的信息。

\begin{note}
 如果直接打开了minicom，没有加-s选项，也可以在minicom界面中用键盘进行操作，操作方法是先按Ctrl-A，再按相应按键。例如：Ctrl-A X退出minicom，Ctrl-A Z显示帮助。
\end{note}

\section{Linux常用命令介绍}
在本课程中，我们使用Linux系统对代码进行编辑、编译，并连接开发板。通过学习并熟悉Linux的基本使用方法，可以更高效的完成本课程的任务。
\subsection{文件夹操作}
表\ref{tab:linux-dircmd}列出主要的Linux系统文件夹命令。

\begin{table}[hbtp]
\begin{tabularx}{\textwidth}{p{6cm}XX}
\toprule
命令名称                                                        & 命令作用                                \\ \midrule
ls                            & 显示当前目录下的所有文件夹和文件     \\
mkdir                       & 建立一个新的文件夹          \\
cd   & 进入某一层文件夹 \\
pwd     &  打印当前文件夹路径 \\
\bottomrule
\end{tabularx}
\caption{文件夹操作命令\label{tab:linux-dircmd}}
\end{table}


绝对路径和相对路径：文件夹命令的操作对象为指定路径的文件夹。在Linux系统中，有绝对路径和相对路径两种指定路径的方式。简单的来说，以/开头的路径会被Linux系统识别为绝对路径，否则为相对路径。因此，绝对路径指的是从根目录/开始的路径，而相对路径则代表从当前位置开始的路径。（使用pwd可以打印当前位置的绝对路径）
需要注意的是，Linux中有几个符号表示着特殊的路径，如表\ref{tab:linux-dircmd_sep}。
\begin{table}[hbtp]
\begin{tabularx}{\textwidth}{p{6cm}XX}
\toprule
路径符合                                                        & 含义                                \\ \midrule
\textasciitilde                          & 用户主文件夹路径，在本课程提供的镜像中，代表/home/stu    \\
.                      & 当前路径         \\
..   & 上一级路径 \\

\bottomrule
\end{tabularx}
\caption{特殊路径\label{tab:linux-dircmd_sep}}
\end{table}

命令举例如表\ref{tab:linux-dircmd_example}。
\begin{table}[hbtp]
\begin{tabularx}{\textwidth}{p{6cm}XX}
\toprule
命令内容                                                      & 含义                                \\ \midrule
cd ..                           & 返回上一级目录   \\
ls /home/stu                      & 打印/home/stu路径下的所有文件夹和文件        \\
mkdir stu   & 在当前路径下创建名为stu的文件夹 \\

\bottomrule
\end{tabularx}
\caption{文件夹命令举例\label{tab:linux-dircmd_example}}
\end{table}


\subsection{文件命令}
表\ref{tab:linux-filecmd}列出主要的Linux系统中进行文件操作的命令。

\par -r递归参数：Linux系统的很多命令都支持-r参数，例如cp命令，cp    test.c    /home/stu是将test.c文件拷贝到路径/home/stu，
   cp -r ./     /home/stu是将本文件夹全部内容拷贝至路径/home/stu。

\par |管道符：管道符用于将管道符前面一个命令的输出作为后面一个命令的输入。例如ls /home | grep ‘stu’的效果相当于在/home路径下的文件夹和文件名称中查找是否有匹配stu字符串的内容。

\begin{table}[hbtp]
\begin{tabularx}{\textwidth}{p{6cm}XX}
\toprule
命令名称                                                      & 含义                                \\ \midrule
cat                          & 查看一个文件的内容   \\
less                      & 支持上下滚动行的查看文件内容的命令       \\
grep   & 查找文件内容 \\
chmod &   改变文件权限\\
cp   &  copy，拷贝\\
rm    &  remove，删除\\
\bottomrule
\end{tabularx}
\caption{文件命令\label{tab:linux-filecmd}}
\end{table}


文件命令使用举例如表\ref{tab:linux-filecmd-example}所示：

\begin{table}[hbtp]
\begin{tabularx}{\textwidth}{p{6cm}XX}
\toprule
命令名称                                                      & 含义                                \\ \midrule
less test.c                          & 显示test.c文件的内容   \\
rm -r stu                    & 删除stu       \\
grep ‘hello’ test.c   & 在test.c中查找匹配字符串hello的内容 \\
chmod +x test.sh &   给test.sh文件赋予执行权限\\

\bottomrule
\end{tabularx}
\caption{文件命令使用示例\label{tab:linux-filecmd-example}}
\end{table}

\subsection{vim操作}
\par vim是一个功能强大的文本编辑器，本课程中，推荐在Linux系统中使用vim来编辑文件。vim也可以用来直接创建新文件，只要后面的文件名并不存在，就会创建一个新的文件。
\par 刚刚启动的vim程序处于命令模式，输入的字符都被vim视为命令而非编辑的文字。输入i,a,s可以进入编辑模式。在编辑模式中，任何字符的输入都会被认为普通输入的文字，除非使用esc键退出编辑模式回到命令模式。
\par 在命令模式下，可以使用冒号键使屏幕下方出现一个冒号，在此时输入的任何字符都会出现在冒号后面。输入w然后回车可以保存当前编辑的文件，输入q然后回车可以退出vim。类似的有q！和wq命令，分别是不保存退出和保存且退出。
\par 在命令模式下还可以使用复制粘贴功能。分别是d、y、p键。
\par 粘贴：p；小写p粘贴到当前游标之后，大写P粘贴到当前游标之前
\par 剪切：d；dd剪切当前行，d+数字+上下方向键剪切当前行和之前之后的n行
\par 复制：y；yy复制当前行，y+数字+上下方向键复制当前行和之前之后的n行
\par 在命令模式下按/键会进入查找模式，通过输入要查找的字符或字符串可以查找，通过n或N查找下一个或上一个。

\section{Git介绍}

Git是一个免费的开源分布式版本控制系统。在其官网\cite{git-website}上的原话是这样的：

Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.

Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows.

\subsection{Git介绍}

我猜很多国内的同学在了解Git之前，先知道了Github这个网站。可能也有相当多的同学在知道如何使用Git之前，就已经先在Github上下载过不少源代码、文件来使用。实际上，Github是一个基于Git建立的第三方仓库，或者说是一个帮你存储代码版本的远程仓库。在使用Git管理代码的版本时，你可以选择将Git产生的一整套东西推送至远程仓库，以方便进行代码备份、合作，而Github就是一个能够提供帮助的网站。

简单地说，Git为每个仓库组织了一个类似有向无环图的数据结构，其结点是不同的版本，而其有向边是每次对仓库中文件进行的修改。Git在版本库中存储不同版本的快照，如果有需要，可以选择其中一个进行阅读、修改。另外，Git仓库中存在一个暂存区，里面是未保存到特定版本的临时修改。

为什么要使用Git呢？这源于代码管理中遇到的现实问题。对于比较大的项目，我们不太可能一个阶段完成修改，在尝试新的一阶段的时候很可能翻车。如果直接在一份代码上修改，就找不到修改前的版本了，容易引入新的bug，或者进行错误修改。这时候，我们就需要一个能以版本为单位管理代码的工具了。如果有更多的工作需要多人分工协作完成，如何让其他成员获得最新修改的代码？如果多人修改了同一个文件，如何合并不同的修改，以形成一个稳定的版本？这就需要一个分布式的代码管理系统，来让分布在各处的修改便于统一整合。在本地，Git可以记录修改信息，管理不同版本，以实现对比和回退等功能。再通过云服务器，Git也可以实现代码的备份以及多人修改的合并。

虽然本实验并不涉及多人合作的情况，但很有可能需要同学们在多个平台对代码进行测试，所以建议还不擅长使用Git的同学们尽快熟悉其使用方法。



\subsection{Git简单命令}

我们建议同学们自行在网络上搜寻与Git有关的资料进行学习。这里列出几条同学们应当学会使用的指令：

\begin{itemize}
    \item add：将当前工作区的修改加到暂存区。
    
    \texttt{git add <file1> ...} 或用 . 代表所有文件
    
    \item commit：将暂存区中的修改确认并提交到当前分支（记为HEAD），这将记录一个版本（默认会有一个master分支），并且清空暂存区
    
    \texttt{git commit -m <commit message>} 其中 \texttt{<commit message>} 为本次提交的备注信息字符串。在命令行中输入字符串时若含有空格，可使用双引号\texttt{""}将其包括起来。
    
    \item \texttt{git checkout} 可以切换当前代码的版本

    \item \texttt{git branch} 可以控制不同分支
    
    \item \texttt{git reset} 可以进行版本回退。这是一个危险操作，请慎用。
    
    \item \texttt{git log} 可以查看不同版本的信息。
    
    \item \texttt{git merege} 可以进行不同分支的合并。
    
    \item \texttt{git rebase} 可以将一个分支的起始位置切换到其他地方。
    
    \item \texttt{git tag} 可以控制标签。

    \item \texttt{git show} 可以展示标签。

    \item \texttt{git clone} 克隆远程仓库到本地

    \item \texttt{git remote} 和云端仓库有关的操作。例如：\texttt{git remote add upstream <URL>} 添加一个远端仓库并标记为 upstream
    
    \item \texttt{git pull} 拉取云端仓库的修改到本地。例如：\texttt{git pull upstream master}

    \item \texttt{git push} 推送本地仓库的修改到云端。例如：\texttt{git push origin master}

\end{itemize}



\subsection{Git学习指南}

请通过查阅网络、阅读手册的方式学习Git的使用。建议学习MIT The Missing Semester的版本控制一课。\cite{missing-semester-vcs}

\section{RISC-V架构介绍}

\subsection{寄存器说明}
关于RISC-V 寄存器说明的详细内容，可以参阅\cite{riscv-reader}\cite{riscv-spec}。

我们的实验基于 RISC-V 64 位架构。与大家在计算机组成原理实验课中接触到的RISC-V 32位架构不同，在 RISC-V 64 架构中，寄存器和指针的宽度都是 64 位。

RISC-V 64 位架构总共有 32 个通用寄存器(General-purpose   register，简称GPR)和若干控制状态寄存器（Control Status Register，简称CSR） 。通用寄存器用于存储和操作通用数据,它们是处理器中用于执行各种计算和数据传输操作的主要寄存器。

CSR是一种特殊的寄存器，由处理器硬件定义和管理。它通常包含一组位字段（bits），每个位字段代表不同的状态或控制标志。这些位字段可以存储和读取处理器的运行状态、中断状态、特权级别、运行模式等信息。
CSR的具体功能和位字段的含义会因不同的处理器体系结构而异。RISC-V 架构中有一组约定的CSR，用于管理和控制处理器的运行状态，如以下示例：
\begin{enumerate}
    \item \textbf{sstatus}: 包含处理器的运行状态和特权级别信息。
    \item \textbf{sie}: 包含处理器中断使能的标志位。
    \item \textbf{scause}：用于存储最近的中断或异常原因。
    \item \textbf{sepc}：存储异常程序计数器，指向中断或异常处理程序的地址。
\end{enumerate}

通过读取和写入CSR的位字段，软件可以查询和修改处理器的运行状态和控制标志。例如，通过将位字段设置为特定的值，可以启用或禁用中断，修改特权级别，触发异常处理等。在 RISC-V 架构中，只能使用控制状态寄存器指令（csrr、csrw 等）访问和修改 CSR。控制状态寄存器指令的使用与特权级相关，相关的内容将在后续的实验中介绍。

CSR在处理器的内部实现中起着重要的作用，它提供了一种机制来管理和控制处理器的行为。同时，CSR也是处理器与操作系统、编译器等软件之间的接口，用于进行状态传递和控制。


\subsection{应用程序二进制接口}

应用程序二进制接口（Application Binary interface，简称 ABI）定义了应用程序二进制代码中相关数据结构和函数模块的格式及其访问方式。这个约定是人为的，硬件上并不强制这些内容，自成体系的软件可以不遵循部分或者全部 ABI。为了和编译器以及其他的库配合，我们应该在写汇编代码时尽量遵循约定。ABI 包含但不限于以下内容：

\begin{enumerate}
    \item 处理器基础数据类型的大小。布局和对齐要求。
    \item 寄存器使用约定。约定通用寄存器的使用方法、别名等。
    \item 函数调用约定。约定参数调用、结果返回、栈的使用。
    \item 可执行文件格式。
    \item 系统调用约定。
\end{enumerate}

下面主要介绍寄存器使用约定。

\subsubsection{通用寄存器使用约定}
RISC-V 中的通用寄存器分为两类，一类在函数调用的过程中不保留，称为\textbf{临时寄存器}。另一类寄存器则对应地称为 \textbf{保存寄存器}。表\ref{tab:registers}罗列出了寄存器的 RISC-V 应用程序二进制接口（ABI）名称和它们在函数调用中是否保留的规定。除了保存寄存器之外，调用者需要保证用于存储返回地址的寄存器( ra )和存储栈指针的寄存器( sp )在函数调用前后保持不变。

简而言之，如果某次函数调用需要改变保存寄存器的值，就需要采用适当的措施在退出函数时恢复保存寄存器的值。在第 \ref{RISC-V-ASM-introduce}
节中将结合相应的汇编代码对寄存器使用约定和函数调用约定做进一步的介绍。

\begin{table}[H]
  \centering                             
  \begin{tabular}{llll}
    \toprule
    寄存器编号 & 助记符 & 用途 & 在调用中是否保留 \\
    \midrule
  \tt x0              & \tt zero            & Hard-wired zero    & --- \\
  \tt x1              & \tt ra              & Return address     & No \\
  \tt x2              & \tt sp              & Stack pointer      & Yes \\
  \tt x3              & \tt gp              & Global pointer     & --- \\
  \tt x4              & \tt tp              & Thread pointer     & --- \\
  \tt x5              & {\tt t0}            & Temporary/alternate link register& No \\
  {\tt x6}--{\tt 7}   & {\tt t1}--{\tt 2}   & Temporaries        & No \\
  \tt x8              & {\tt s0}/\tt fp     & Saved register/frame pointer & Yes \\
  \tt x9              & {\tt s1}            & Saved register     & Yes \\
  {\tt x10}--{\tt 11} & {\tt a0}--{\tt 1}   & Function arguments/return values & No \\
  {\tt x12}--{\tt 17} & {\tt a2}--{\tt 7}   & Function arguments & No \\
  {\tt x18}--{\tt 27} & {\tt s2}--{\tt 11}  & Saved registers    & Yes \\
  {\tt x28}--{\tt 31} & {\tt t3}--{\tt 6}   & Temporaries        & No \\
  \hline
  {\tt f0}--{\tt 7}   & {\tt ft0}--{\tt 7}  & FP temporaries     & No \\
  {\tt f8}--{\tt 9}   & {\tt fs0}--{\tt 1}  & FP saved registers & Yes \\
  {\tt f10}--{\tt 11} & {\tt fa0}--{\tt 1}  & FP arguments/return values & No \\
  {\tt f12}--{\tt 17} & {\tt fa2}--{\tt 7}  & FP arguments       & No \\
  {\tt f18}--{\tt 27} & {\tt fs2}--{\tt 11} & FP saved registers & Yes \\
  {\tt f28}--{\tt 31} & {\tt ft8}--{\tt 11} & FP temporaries     & No \\
    \bottomrule
  \end{tabular}
  \caption{RISC-V 通用寄存器\label{tab:registers}\cite{riscv-spec}}
\end{table}


\section{RISC-V汇编介绍}\label{RISC-V-ASM-introduce}
\subsection{RISC-V汇编语言}
关于RISC-V汇编语言的详细内容，可以参阅\cite{riscv-reader}\cite{riscv-asm-manual}\cite{riscv-spec}。

在此，我们讲述一些C语言和RISC-V语言的对应关系，便于大家后面编写汇编代码。汇编语言可以理解为机器语言的直接翻译，是对于处理器的最直接的操作。RISC类型的处理器使用load/store类指令将变量在内存与寄存器间进行转移，除了这类指令外，其他指令都是在寄存器与寄存器之间的操作。

为了便于大家理解汇编如何编写，下面我们演示一下，我们所熟悉的C语言是如何被转换为汇编的。作为例子，这里选用一个简单的选择排序代码来作为演示。为了演示到所有的情况，我们有意使用了循环、函数调用等元素。

% \begin{codeBoxWithCaption}{C语言选择排序例程\label{code:riscv-example}}
\lstinputlisting[label=code:riscv-example,caption=C语言选择排序例程,language=c]{codes/riscv-example.c}
% \label{code:riscv-example}
% \end{codeBoxWithCaption}


那么，上面这段C代码对应的汇编代码是什么样呢？

首先，GCC有一个特性：所有的循环，都会换成\texttt{do{}while();}的形式来实现。
例如，GCC翻译出来的循环用C语言形象地表示是这个样子的：
\begin{lstlisting}[language=c]
for (int i = 0; i < n; ++i) {
   // ...
}
// 会被翻译成
int i = 0;
if (i >= n) goto END;
do {
   // ...
   ++i;
} while (i < n);
END:
// 进一步被翻译成
int i = 0;
goto L2;
L1:
  // ...
  ++i;
L2:
  if (!(i<n)) goto END;
  goto L1;
END:
\end{lstlisting}

函数调用会将第一个参数放在a0寄存器，第二个参数放在a1寄存器，依次类推，最后用call指令调用相应的函数。
\begin{lstlisting}
ld a1, -24(s0); # 假设第二个参数位于-24(s0)
ld a0, -20(s0); # 假设第二个参数位于-20(s0)
call func # 相当于func(a0,a1);
\end{lstlisting}

进入函数时，先分配栈空间。分配方法就是将栈指针减去需要的空间字节数（栈是向下增长的）。sp到sp-X这X字节的空间就是当前函数运行所需的栈空间。将保存寄存器和返回地址寄存器( ra )的值存储在这部分栈空间中，退出时恢复。对于调用者来说，保存寄存器和返回地址寄存器( ra )的值在函数调用前后是不变的。栈指针( sp )的值也会在函数退出时进行恢复。此外，如果函数中使用了较多的局部变量，也会在栈空间上多开辟一部分空间用于存储局部变量。在内核编程中，内核栈的大小通常是有限的，如果函数中使用了大量的局部数据，很可能会发生栈溢出，覆盖了其他的内存区域，而引发奇怪的问题。
\begin{lstlisting}
func:
  addi sp,sp,-32
  sd   s0, 0(sp)
  sd   s1, 8(sp)
  sd   ra, 16(sp)
  # ...
  ld   ra, 16(sp)
  ld   s1, 8(sp)
  ld   s0, 0(sp)
  addi sp,sp,32
  jr ra
\end{lstlisting}

一般汇编里加载地址有两个常用方式：绝对地址加载和PC相对加载。

直接加载绝对地址的示例如下：
\begin{lstlisting}
.section .text
.globl _start
_start:
        lui a0,       %hi(msg)       # load msg(hi)
        addi a0, a0,  %lo(msg)       # load msg(lo)
        jal ra, puts
2:      j 2b

.section .rodata
msg:
        .string "Hello World\n"
\end{lstlisting}

PC相对的地址加载方式如下：
\begin{lstlisting}
.section .text
.globl _start
_start:
1:      auipc a0,     %pcrel_hi(msg) # load msg(hi)
        addi  a0, a0, %pcrel_lo(1b)  # load msg(lo)
        jal ra, puts
2:      j 2b

.section .rodata
msg:
        .string "Hello World\n"
\end{lstlisting}


下面是C编译器翻译出来的代码\ref{code:riscv-example}对应的RISC-V汇编代码。
% \begin{codeBoxWithCaption}{RISC-V汇编选择排序例程\label{code:riscv-example-asm}}
\lstinputlisting[label=code:riscv-example-asm,caption=RISC-V汇编选择排序例程]{codes/riscv-example.s}
% \end{codeBoxWithCaption}

% \subsection{通用寄存器使用约定}
% RISCV中一共有32个通用寄存器，软件在使用这些寄存器的时候一般要遵循一定的约定。编译器在生成代码时，会按照使用约定生成。
% 为了和编译器及其他的库配合，我们在写汇编代码时也应当尽量遵循约定。当然，这个约定是人为约定的，即使不遵循约定，硬件也
% 可以正常执行，只是软件之间无法顺利配合了而已。每个寄存器的使用约定如表\ref{tab:registers}所示。

% \begin{table}[H]
%   \centering                             
%   \begin{tabular}{llll}
%     \toprule
%     寄存器编号 & 助记符 & 用途 & 在调用中是否保留 \\
%     \midrule
%   \tt x0              & \tt zero            & Hard-wired zero    & --- \\
%   \tt x1              & \tt ra              & Return address     & No \\
%   \tt x2              & \tt sp              & Stack pointer      & Yes \\
%   \tt x3              & \tt gp              & Global pointer     & --- \\
%   \tt x4              & \tt tp              & Thread pointer     & --- \\
%   \tt x5              & {\tt t0}            & Temporary/alternate link register& No \\
%   {\tt x6}--{\tt 7}   & {\tt t1}--{\tt 2}   & Temporaries        & No \\
%   \tt x8              & {\tt s0}/\tt fp     & Saved register/frame pointer & Yes \\
%   \tt x9              & {\tt s1}            & Saved register     & Yes \\
%   {\tt x10}--{\tt 11} & {\tt a0}--{\tt 1}   & Function arguments/return values & No \\
%   {\tt x12}--{\tt 17} & {\tt a2}--{\tt 7}   & Function arguments & No \\
%   {\tt x18}--{\tt 27} & {\tt s2}--{\tt 11}  & Saved registers    & Yes \\
%   {\tt x28}--{\tt 31} & {\tt t3}--{\tt 6}   & Temporaries        & No \\
%   \hline
%   {\tt f0}--{\tt 7}   & {\tt ft0}--{\tt 7}  & FP temporaries     & No \\
%   {\tt f8}--{\tt 9}   & {\tt fs0}--{\tt 1}  & FP saved registers & Yes \\
%   {\tt f10}--{\tt 11} & {\tt fa0}--{\tt 1}  & FP arguments/return values & No \\
%   {\tt f12}--{\tt 17} & {\tt fa2}--{\tt 7}  & FP arguments       & No \\
%   {\tt f18}--{\tt 27} & {\tt fs2}--{\tt 11} & FP saved registers & Yes \\
%   {\tt f28}--{\tt 31} & {\tt ft8}--{\tt 11} & FP temporaries     & No \\
%     \bottomrule
%   \end{tabular}
%   \caption{RISC-V 通用寄存器\label{tab:registers}\cite{riscv-spec}}
% \end{table}


\subsection{RISC-V常用汇编指令}

RISC-V的算术、逻辑运算等指令用法可以参考\cite{riscv-reader}一书。
RISC常用伪指令如表\ref{csr-pseudos}和表\ref{pseudos}所示。伪指令是为了编写汇编方便所准备的指令，会被汇编器自动翻译成多条汇编指令。

\begin{table}[H]
    \begin{small}
        \begin{center}
            \begin{tabularx}{\textwidth}{l l X}
                \toprule
                伪指令 & 基础指令(即被汇编器翻译后的指令) & 含义 \\
                \midrule
                {\tt fence} & {\tt fence iorw, iorw} & Fence on all memory and I/O \\
                \hline
                {\tt rdinstret[h] rd} & {\tt csrrs rd, instret[h], x0} & Read instructions-retired counter \\
                {\tt rdcycle[h] rd} & {\tt csrrs rd, cycle[h], x0} & Read cycle counter \\
                {\tt rdtime[h] rd} & {\tt csrrs rd, time[h], x0} & Read real-time clock \\
                \hline
                {\tt csrr rd, csr} & {\tt csrrs rd, csr, x0} & Read CSR \\
                {\tt csrw csr, rs} & {\tt csrrw x0, csr, rs} & Write CSR \\
                {\tt csrwi csr, imm} & {\tt csrrwi x0, csr, imm} & Write CSR, immediate \\
                \hline
                {\tt j offset} & {\tt jal x0, offset} & Jump \\
                {\tt jal offset} & {\tt jal x1, offset} & Jump and link \\
                {\tt jr rs} & {\tt jalr x0, 0(rs)} & Jump register \\
                {\tt ret} & {\tt jalr x0, 0(x1)} & Return from subroutine \\
                \tt call offset & {\tt auipc x1, ${\tt offset[31:12]} + {\tt offset[11]}$} & Call far-away subroutine \\
                                & {\tt jalr x1, offset[11:0](x1)}                          & \\
                \tt tail offset & {\tt auipc x6, ${\tt offset[31:12]} + {\tt offset[11]}$} & Tail call far-away subroutine \\
                                & {\tt jalr x0, offset[11:0](x6)}                          & \\
                \bottomrule
            \end{tabularx}
        \end{center}
    \end{small}
    \caption{RISC-V 伪指令\cite{riscv-spec}}
    \label{csr-pseudos}
\end{table}

% 汇编多讲一点，作业劝退
% 汇编作业涉及到内存的访问
% 堆栈传参，栈的使用
% 两个汇编作业（下次讨论）：
% 第一个访存，寄存器，调用
\begin{table}[H]
\begin{small}
\begin{center}
\begin{tabularx}{\textwidth}{l l X}
\toprule
伪指令 & 基础指令(即被汇编器翻译后的指令) & 含义 \\ \midrule

\tt la rd, symbol (\emph{non-PIC}) & {\tt auipc rd, ${\tt delta[31:12]} + {\tt delta[11]}$} & Load absolute address, \\
                  & {\tt addi rd, rd, delta[11:0]}                         & where ${\tt delta} = {\tt symbol} - {\tt pc}$ \\[1ex]
\tt la rd, symbol (\emph{PIC})& {\tt auipc rd, ${\tt delta[31:12]} + {\tt delta[11]}$} & Load absolute address, \\
                  & {\tt l\{w|d\} rd, rd, delta[11:0]}                         & where ${\tt delta} = {\tt GOT[symbol]} - {\tt pc}$ \\[1ex]
\tt lla rd, symbol& {\tt auipc rd, ${\tt delta[31:12]} + {\tt delta[11]}$} & Load local address, \\
                  & {\tt addi rd, rd, delta[11:0]}                         & where ${\tt delta} = {\tt symbol} - {\tt pc}$ \\[1ex]
\tt l\{b|h|w|d\} rd, symbol & {\tt auipc rd, ${\tt delta[31:12]} + {\tt delta[11]}$} & Load global \\
                            & {\tt l\{b|h|w|d\} rd, delta[11:0](rd)}                 & \\[1ex]
\tt s\{b|h|w|d\} rd, symbol, rt & {\tt auipc rt, ${\tt delta[31:12]} + {\tt delta[11]}$} & Store global \\
                               & {\tt s\{b|h|w|d\} rd, delta[11:0](rt)}                 & \\[1ex]
\multicolumn{3}{p{.99\textwidth}}{\small \em The base instructions use {\tt pc}-relative addressing, so the linker subtracts {\tt pc} from {\tt symbol} to get {\tt delta}.  The linker adds {\tt delta[11]} to the 20-bit high part, counteracting sign extension of the 12-bit low part.} \\
~\\
\hline
{\tt nop} & {\tt addi x0, x0, 0} & No operation \\
{\tt li rd, immediate} & {\em Myriad sequences} & Load immediate \\
{\tt mv rd, rs} & {\tt addi rd, rs, 0} & Copy register \\
{\tt not rd, rs} & {\tt xori rd, rs, -1} & One's complement \\
{\tt neg rd, rs} & {\tt sub rd, x0, rs} & Two's complement \\
{\tt negw rd, rs} & {\tt subw rd, x0, rs} & Two's complement word \\
{\tt sext.w rd, rs} & {\tt addiw rd, rs, 0} & Sign extend word \\
{\tt seqz rd, rs} & {\tt sltiu rd, rs, 1} & Set if $=$ zero \\
{\tt snez rd, rs} & {\tt sltu rd, x0, rs} & Set if $\neq$ zero \\
{\tt sltz rd, rs} & {\tt slt rd, rs, x0} & Set if $<$ zero \\
{\tt sgtz rd, rs} & {\tt slt rd, x0, rs} & Set if $>$ zero \\
\hline
{\tt beqz rs, offset} & {\tt beq rs, x0, offset} & Branch if $=$ zero \\
{\tt bnez rs, offset} & {\tt bne rs, x0, offset} & Branch if $\neq$ zero \\
{\tt blez rs, offset} & {\tt bge x0, rs, offset} & Branch if $\leq$ zero \\
{\tt bgez rs, offset} & {\tt bge rs, x0, offset} & Branch if $\geq$ zero \\
{\tt bltz rs, offset} & {\tt blt rs, x0, offset} & Branch if $<$ zero \\
{\tt bgtz rs, offset} & {\tt blt x0, rs, offset} & Branch if $>$ zero \\
\hline
{\tt bgt rs, rt, offset} & {\tt blt rt, rs, offset} & Branch if $>$ \\
{\tt ble rs, rt, offset} & {\tt bge rt, rs, offset} & Branch if $\leq$ \\
{\tt bgtu rs, rt, offset} & {\tt bltu rt, rs, offset} & Branch if $>$, unsigned \\
{\tt bleu rs, rt, offset} & {\tt bgeu rt, rs, offset} & Branch if $\leq$, unsigned \\
\bottomrule

\end{tabularx}
\end{center}
\end{small}
\caption{RISC-V 伪指令(续)\cite{riscv-spec}}
\label{pseudos}
\end{table}

\section{编译及相关工具介绍}
\subsection{从编译到执行}
我们即将用C语言来实现操作系统内核，但是C语言这样的高级语言离机器能够理解和运行还有不小的差距。对于一个不复杂的应用程序来说（例如helloworld），让它运行起来的最简单的方式是使用GCC编译，输入以下命令：

\begin{lstlisting}[language=bash]
$ gcc hello.c -o hello
\end{lstlisting}

在同级文件夹下将会生成一个可执行文件hello。这里需要注意的是，这个hello文件目前是存放在硬盘上的，而计算机执行程序的时候需要从内存取指令，这就意味着我们在执行它的时候，hello的程序代码首先被搬到了内存中。那么，这个搬运的过程是不是原封不动地将代码从硬盘拷贝到内存呢？并没有这么简单，这个可执行文件实际上是ELF格式的，而不仅仅是简单平铺的目标机器代码。关于ELF格式的具体内容会在未来的实验中进一步学习，在这里只需要知道，这个ELF文件中有许多不同作用的段，除了包含目标代码的代码段，至少包括数据段、bss段，还可能包括字符串表、符号表、动态链接信息、调试信息、只读数据段等各种各样的段。总结来说，所谓ELF文件只是Linux系统在硬盘中存放二进制程序的一种中间状态，仍然需要对它做进一步的解读才能让机器开始执行。

当我们有多个C文件时，事情发生了变化。一方面，我们可以和单文件一样，将多个文件名同时提供给gcc作为参数，直接产生可执行文件，例如：

\begin{lstlisting}[language=bash]
$ gcc hello.c main.c -o hello
\end{lstlisting}

这样一个命令其实包含了多个行为，GCC编译器首先会将每个c文件单独编译，各自产生一个ELF文件，这些文件包含了目标代码，称为目标文件（.o文件）。但显然每个ELF文件都是不完整和无法运行的，main.c里可能调用了一个位于hello.c的函数，这就需要进行一步链接操作，将多个ELF文件拼合起来。具体来说，链接过程需要合并各个ELF文件的段，合并符号表，并且对变量、函数等重定位，让不同文件中的函数能互相调用。上面这个命令的效果等同于以下操作：

\begin{lstlisting}[language=bash]
$ gcc -c hello.c -o hello.o
$ gcc -c main.c -o main.o
$ gcc hello.o main.o -o hello
\end{lstlisting}

在我们的项目源文件数量比较少时，似乎看不出独立编译再链接这个行为的意义，直接将所有文件放到一起直接编译出完整的可执行文件好像更省事。随着工程规模的增加，模块化的设计越来越有必要，对整个工程进行完整编译的时间成本显著提高，并且对代码中一个小地方的改动要将所有文件从头重新编译，还伴随着库文件重复编译的问题等等。

\subsection{编译流程}
为了更好地理解和控制编译的行为，以帮助我们写出符合需要的代码，还需要进一步了解编译过程中的几个步骤：
\textbf{预编译、编译、汇编、链接}（如图\ref{fig:compile-flow}所示）。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{compile-flow}
	\caption{编译流程}\label{fig:compile-flow}
\end{figure}

\textbf{预编译}：识别文件中的一部分宏，如\#define、\#include等，完成文本级的替换，此时还不涉及对代码实际功能的操作。

\textbf{编译}：将高级语言（C语言等编程语言）转化为汇编语言，汇编语言仍然是文本形式的，无法直接运行，但是比C语言的文本结构简单的多，看上去基本就是机器语言的样子了。

\textbf{汇编}：将汇编语言转化为机器能识别的二进制目标代码，到这一步这个程序才初步具备了被执行的一些要素。

\textbf{链接}：将多个分离的二进制代码合并成最终的可执行文件。

下面将通过一个简单的例子来具体阐述各个阶段的行为。项目代码有hello.h(Listing \ref{code:hello-h})、hello.c(Listing
\ref{code:hello-c})、main.c(Listing \ref{code:main-c})三个文件。这3个文件主要完成输出”hello world”的简单工作。

% \begin{codeBoxWithCaption}{hello.h\label{code:hello-h}}
  \lstinputlisting[label=code:hello-h,caption=hello.h,language=c]{codes/hello.h}
% \end{codeBoxWithCaption}
% \begin{codeBoxWithCaption}{hello.c\label{code:hello-c}}
  \lstinputlisting[label=code:hello-c,caption=hello.c,language=c]{codes/hello.c}
% \end{codeBoxWithCaption}
% \begin{codeBoxWithCaption}{main.c\label{code:main-c}}
  \lstinputlisting[label=code:main-c,caption=main.c,language=c]{codes/main.c}
% \end{codeBoxWithCaption}

\subsubsection{预编译}
GCC编译器可以分步执行上述编译过程中的每个步骤，我们只需要在gcc命令后面添加参数-E就可以只进行预编译这第一步，现在我们在终端输入下列命令：
\begin{lstlisting}[language=bash]
$ gcc -E hello.c -o hello.i
$ gcc -E main.c -o main.i
\end{lstlisting}

我们打开生成的文件，hello.i和main.i，可以发现，里面的内容如代码
\ref{code:main-i}所示。这里只展示main.i，因为hello.i引用了标准输入输出，导致预编译完的文件很长，限于篇幅不再展示。

% \begin{codeBoxWithCaption}{预编译结果\label{code:main-i}}
\lstinputlisting[label=code:main-i,caption=预编译结果,language=c]{codes/main.i}
% \end{codeBoxWithCaption}
可以发现，相对于预编译之前，生成的新文件只是简单地做了一下宏替换，将include的头文件的内容放进了文本中，而没有进行任何语言间的转化。

\subsubsection{编译}
在编译这一步骤，编译器要正式开始工作了。同理，我们将刚才生成的.i文件继续编译，添加-S参数，在终端输入以下命令：

\begin{lstlisting}[language=bash]
$ gcc -S hello.i -o hello.s
$ gcc -S main.i -o main.s
\end{lstlisting}

我们打开生成的.s文件，发现里面内容如下（同样只展示main.s,如代码\ref{code:main-s}所示）：

% \begin{codeBoxWithCaption}{编译结果\label{code:main-s}}
\lstinputlisting[label=code:main-s,caption=编译结果]{codes/main.s}
% \end{codeBoxWithCaption}

可以发现，原来的\textbf{C语言代码已经被转化成为了汇编代码}（汇编代码的种类由你所使用的编译器决定，此处例子为X86汇编代码），这正是编译这一步所进行的工作。在对汇编语言有基本的了解后，就能大致阅读这段代码了，层次化、结构化的高级语言被转化成了线性的、连续排列的指令，每一行都有指令助记符和操作数，以及其他必要的提示语句。

你可能知道，编译器除了将高级代码按照语言规范逐条生成效果等价的汇编语言之外，还会对代码本身做一定程度的优化，例如削减变量、常量替换、循环展开等等，这些优化大部分是在这一步完成的。

\subsubsection{汇编}
汇编这一步骤，进一步将编译所生成的汇编代码转化成机器能识别的二进制机器代码，然后将其中的数据、代码等以ELF格式打包成目标文件。我们在终端里输入以下命令：

\begin{lstlisting}[language=bash]
$ gcc -c hello.s -o hello.o
$ gcc -c main.s -o main.o
\end{lstlisting}

打开生成的.o文件，里面的内容如图\ref{fig:main-o}所示。是的！我们生成的文件已经是一个二进制文件，里面存放的数据都是只有机器才能识别的机器代码啦。除了少量的字符串作为数据保存，其余部分已经无法以文本的格式阅读了。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.6\textwidth]{main-o}
	\caption{编译出的main.o}\label{fig:main-o}
\end{figure}

\subsubsection{链接}
到目前为止，我们生成的文件有main.o和hello.o这2个二进制文件，但是因为它们是彼此分离的，现在还不能直接运行。所以，我们需要通过链接这一重要的步骤，将彼此分离的二进制代码合并成最终的可执行文件。我们在终端输入以下命令：
\begin{lstlisting}[language=bash]
$ gcc hello.o main.o -o main
$ ./main
Hello World!
\end{lstlisting}

最终，我们的“Hello World”项目从3个文件，合并成为了1个名为main的可执行文件，操作系统可以去执行它并且打印出“Hello World！”。是不是很神奇？在链接阶段，我们也经常会直接调用链接器ld代替gcc，它们的效果是一致的。

\subsection{编译优化}
在内核编程中，熟知编译优化相关的知识非常重要。成熟的内核代码一定要经得起编译优化，在优化中保证行为的正确性。我们熟知的 Linux 内核就是使用 -O2 编译优化选项进行编译的。gcc 提供了不同级别的优化选项，可以在编译时添加 -OX 选项指定，其中 'X' 代表编译优化级别。

在这里，我们以往届学生在使用编译优化选项时出现的问题为例，提醒大家在编写代码时一定要考虑不同的优化选项下生成的目标代码的行为差异。

\subsubsection{案例分析}

代码 \ref{code:invoke_syscall_c} 展示了一段往届同学使用内联汇编进行系统调用的错误代码。这里大家不用深究系统调用的概念，只需要知道该段代码的功能是将参数中的 sysno 放置到 a7 寄存器中，arg0 \textasciitilde arg4 分别按顺序放置到 a0 \textasciitilde a4 寄存器中。

% \begin{codeBoxWithCaption}{invoke\_syscall.c 内敛汇编展示\label{code:invoke_syscall_c}}
  \lstinputlisting[label=code:invoke_syscall_c,caption=invoke\_syscall.c,language=c]{codes/invoke_syscall.c}
% \end{codeBoxWithCaption}

在调用 invoke\_syscall 函数时，根据 RISC-V 函数调用 ABI 中指定的参数放置规定，sysno 已经放置到了 a0 寄存器中，剩余的参数也按照顺序保存到了 a1 \textasciitilde a5 寄存器当中。于是，在内联汇编代码中只做了简单的寄存器值交换动作。

代码 \ref{code:call_invoke_syscall} 展示了invoke\_syscall 的一个简单封装调用。

% \begin{codeBoxWithCaption}{-O0 优化选项下调用 invoke\_syscall \label{code:call_invoke_syscall}}
  \lstinputlisting[label=code:call_invoke_syscall,caption=-O0 优化选项下调用 invoke\_syscall,language=c]{codes/call_invoke_syscall.c}
% \end{codeBoxWithCaption}

这段代码在 -O0 优化选项下自然没有任何问题，因为 RISC-V ABI会将正确的参数传递到对应的寄存器中。但在 -O2 优化选项下，invoke\_syscall 函数会被优化为内联函数，同时， gcc 识别到传递给 invoke\_syscall 的参数没有被使用到，因此直接将传参的步骤省去，优化后的代码等价于代码 \ref{code:optimization_invoke_syscall} ，直接丢失了原本要保存到 a7 寄存器中的 SYS\_EXHIBIT 参数，并且参数也没有按照预期移动到 a0 \textasciitilde a4 寄存器当中。

% \begin{codeBoxWithCaption}{-O2 优化选项下调用 invoke\_syscall \label{code:optimization_invoke_syscall}}
  \lstinputlisting[label=code:optimization_invoke_syscall,caption=-O2 优化选项下调用 invoke\_syscall,language=c]{codes/call_invoke_syscall_optimization.c}
% \end{codeBoxWithCaption}

这段原本在 -O0 选项下可以正常工作的代码在 -O2 下出现了问题。具体的原因在于，我们需要在内联汇编中告诉编译器需要使用到具体的参数，使得编译器优化时保证参数的正确传递，如代码 \ref{code:correct_invoke_syscall}所示。

% \begin{codeBoxWithCaption}{修正后的 invoke\_syscall \label{code:correct_invoke_syscall}}
  \lstinputlisting[label=code:correct_invoke_syscall,caption=修正后的 invoke\_syscall,language=c]{codes/correct_invoke_syscall.c}
% \end{codeBoxWithCaption}


经过了上述的流程，你应该已经对一个项目从编译到执行的步骤有了清楚的认识，但仍然会有一些问题在困扰你：难道每编译一次项目都要手打这么多复杂命令吗？链接是通过什么规则将这些可执行文件合并在一起的呢？生成的可执行文件要如何在不运行的情况下做静态分析，以确定编译出的机器码符合我们的预期呢？

当然，这些问题我们都将在接下来的部分具体阐述：介绍项目编译利器——Makefile、如何通过链接器脚本控制我们的链接过程、以及方便快捷的反汇编命令——objdump。

\subsection{Makefile}
类似上面的例子，我们使用几行简单的命令就能够轻易地搞定一个小程序的编译过程，那么对于更大的程序呢？例如，我们即将着手实现的内核可能会有数十个C文件需要编译，这些文件分散在以程序逻辑结构划分的诸多文件夹内；而一个实际的软件工程项目中，文件更是成百上千，显然不可能依靠人工手动逐个编译链接起来。

那么写一个shell脚本如何？shell脚本允许我们将需要执行的编译命令预先写好，需要编译的时候只需要运行这个脚本就可以了。这种方法没有手动编译繁琐，但是可扩展性仍然很受限。一方面，编译的时候除了要关心编译哪个文件，还需要管理好头文件、静态链接库、预定义的参数、繁多的编译选项等等，要写出这样一个脚本就是繁重的重复劳动，一旦其中某个文件做了修改，需要重新编译的时候，整个脚本的全部流程都要重新执行一遍；另一方面，如果项目功能调整，需要增加或者删除文件，或者文件目录结构发生了变化，就要仔细校对脚本中每个相关的地方，并且保证别的命令不能出错或者缺乏依赖，要维护这样一个脚本的成本过于高昂。

所幸，在Linux下，有着Makefile这一利器，它能够帮助我们简化书写，执行编译过程。Makefile仍然是一个脚本文件，在shell中能完成的指令同样都可以写入Makefile作为其自动化流程的一部分。与shell不同的是，你只需要设定好编译的规则，而不需要为每个单独的文件特意编写一条命令。一条规则一般包括目标、依赖、规则内容三部分，目标和依赖会用冒号分隔，具体的规则另起一行，例如我们在目录中创建一个名为“Makefile”的文件：

\begin{lstlisting}[language=make]
hello: hello.o main.o
    gcc hello.o main.o -o hello

hello.o: hello.c
    gcc -c hello.c -o hello.o

main.o: main.c
    gcc -c main.c -o main.o
\end{lstlisting}

想要完成hello这个目标，你只需要一条简单的命令：

\begin{lstlisting}[language=bash]
$ make hello
\end{lstlisting}

或者Makefile默认会完成第一个目标：

\begin{lstlisting}[language=bash]
$ make
\end{lstlisting}

Makefile的一个很大的优势在于，它能够自动管理规则之间的依赖，当你想完成hello这个目标的时候，它就会先将其依赖的main.o和hello.o完成；此外，Makefile每次被执行的时候并不会从头开始，例如，某个源文件hello.c被修改了需要重新编译，那么make命令在运行前扫描文件的时间戳，就会发现hello.c的最后修改时间发生了变化，从而识别出依赖hello.c的hello.o和hello这两个目标需要被重新执行，而不需要重新执行main.o这个目标。这样就实现了我们想要的增量编译，在文件数量很多的情况下，能够大大节省每次编译花费的时间。

Makefile的优点可以总结为：规则式管理（编译什么，按什么顺序，怎么编译）、增量式编译、一般不需要做大幅修改。

在本次操作系统实验课中，大部分的项目代码我们都已经写好了Makefile，大家只需要能够看懂简单的Makefile并且学会使用它。除了编译，其他许多需要执行的命令也会一并整合进Makefile，例如启动QEMU模拟器、拷贝镜像进SD卡等等，省去翻找和输入命令的时间，只需要使用“make 目标”这样一行命令，就可以一步执行对应的所有指令。如果你对某个操作具体使用了哪些命令感兴趣，可以参看这些Makefile。

这里再给出一个实用的make参数-n，使用这个参数能够看到你即将运行的一次make将会具体执行什么样的命令，而不实际执行它们。例如，在只修改了hello.c之后可以运行：

\begin{lstlisting}[language=bash]
$ make -n hello
gcc -c hello.c -o hello.o
gcc hello.o main.o -o hello
\end{lstlisting}

到这里，你可能会觉得上面那种Makefile写起来还是太麻烦，比shell脚本没有好多少，这是因为Makefile还有很多能提高生产力的写法和技巧，例如默认变量、自动变量、函数、默认规则等等。但这些规则很难一下子全部掌握，一个复杂的Makefile也有一定的理解门槛，如果你仍希望更加深入的理解Makefile，熟悉掌握相关知识的话，可以查阅网上更多的资料\cite{ruan-makefile}\cite{chen-makefile-debug}\cite{chen-makefile}，了解如何编写Makefile。

\subsection{链接器脚本}
前几节中说过，在链接阶段，多个.o文件会被合并成为一个ELF格式的可执行文件。ELF里包含各种段，每个段包含的内容也不一样，有的包含数据，有的包含代码。在刚才的demo里，我们直接使用了gcc命令进行链接，这个链接使用了默认的规则，因此生成的ELF文件的布局，比如代码段与数据段的位置，我们都是不清楚的。但在内核编译的过程中，我们需要将很多内容放到固定的位置，比如内核的入口函数地址（清楚了入口地址，我们才能跳到这里去运行内核代码）、栈堆地址等等。因此，我们需要自己制定规则，去布置各个段在ELF文件中的位置，这就是链接器脚本的功能。

链接器脚本的书写是一个繁琐的过程，我们已经在大家以后的代码框架中准备好了链接器脚本，配合Makefile一起使用，直接使用就可以了。如果想要在链接过程中使用自己写的链接器脚本（.lds文件），可以在ld命令中加入-T参数指定。

此外，在汇编或者C代码中，链接器脚本里面定义的符号是可以直接引用的，例如表示数据段起始位置的符号\_\_DATA\_BEGIN\_\_。但是请注意，只有这个符号的地址是有意义的，这个地址里面并没有存放什么有意义的值。所以在汇编中，我们可以使用la指令来加载其地址；在C语言中，可以先声明extern之后再使用\&获得其地址。

\subsection{objdump}
由于内核要在没有其他软件辅助的情况下管理机器底层的资源，需要最终生成的目标代码非常准确，C语言在很多时候未必能精准地描述这些操作。在C语言编译、链接的过程中，可能会产生各种各样的不确定性，我们有时需要去检查生成的目标文件中的指令是否符合预期。但是，目标文件本身是个二进制文件，无法以文本的形式展现出来，我们可以使用xxd命令来以16进制的文本打印这个文件：

\begin{lstlisting}[language=bash]
$ xxd hello
\end{lstlisting}

屏幕上会看到如图\ref{fig:xxd}的输出。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.6\textwidth]{xxd}
	\caption{xxd命令的输出}\label{fig:xxd}
\end{figure}

从这里，你可以看到这个文件的全貌，左侧是以16进制打印的内容，右侧是试图以ASCII码方式读取16进制内容得到的字符，能够基本看出特定地址处有没有数据、是不是全0，以及链接以后各个段的排布，在检查ELF文件布局的时候是很有用的。

如果想更细致地调试，这样的输出仍然十分冗长，且没有被逐条翻译成汇编指令，不具备可读性。objdump反汇编工具能够帮助我们将目标文件（.o或者可执行文件）翻译回汇编语言，从而能逐条指令地检查代码正确性，是我们定位问题的有力手段。

例如，如果我们想反汇编一个可执行文件hello包含代码的部分，可以输入命令：

\begin{lstlisting}[language=bash]
$ objdump -d hello > hello.S
\end{lstlisting}

表示将反汇编出的汇编结果输出到hello.S文件中，在该文件中能看到不同的段、不同的函数下具体的指令。使用不同的编译工具链中的objdump以反汇编不同指令集下的目标代码。进一步，如果在编译时加入了-g选项，表示目标文件会包含调试信息，那么反汇编时可以使用-S参数将反汇编结果和C代码对应起来，以及-l参数将结果与源文件和行号对应起来。例如：

\begin{lstlisting}[language=bash]
$ gcc -c hello.c -g -o hello.o
$ objdump -S -l hello.o > hello.S
\end{lstlisting}

如果只想看特定某个段的内容，还可以加入-j <section>选项来指定。以上是最常用的objdump命令的使用方法。

\section{QEMU和gdb调试}

本节将介绍本课程的软件模拟器调试工具QEMU模拟器\cite{qemu-website}，以及基于QEMU模拟器的gdb调试基本技巧。在我们提供的虚拟机环境中已经安装了可以完全模拟开发板功能的QEMU模拟器以及gdb工具链，大家可以善用于日常的开发调试中。

\subsection{QEMU的启动}

 QEMU 的启动命令已经包含在之后我们发布给大家的代码文章中的 Makefile 文件当中，下面给出一段启动 QEMU 模拟器的命令行示例：

\begin{lstlisting}[language=bash]
/home/stu/OSLab-RISC-V/qemu/riscv64-softmmu/qemu-system-riscv64 
    -nographic -machine virt -m 256M 
    -kernel /home/stu/OSLab-RISC-V/u-boot/u-boot 
    -bios none 
    -drive if=none,format=raw,id=image,file=./build/image 
    -device virtio-blk-device,drive=image
\end{lstlisting}

其中 qemu-system-riscv64 为 QEMU 模拟器；-nographic -machine virt -m 256M 参数表示虚拟板卡的配置：关闭图形界面，并且虚拟板卡的物理内存为 256M；-kernel /home/stu/OSLab-RISC-V/u-boot/u-boot 表示 QEMU 模拟器运行的 kernel 镜像的路径。

 QEMU 为了模拟开发板的从 SD 卡加载和启动操作系统的流程，也模拟了类似的USB设备。上述命令行中的 -drive if=none,format=raw,id=image,file=./build/image  -device virtio-blk-device,drive=image，表示将 ./build/image 文件作为块设备，其实也就是模拟出来的 SD 卡。在后续的实验框架中，需要将我们的操作系统制作为镜像，作为 QEMU 虚拟出来的 SD 卡使用。上述命令行中的整个流程表现为: QEMU 模拟器启动 u-boot ,随后在 u-boot 命令行中输入命令从 SD 卡中启动我们的操作系统。

 QEMU 的退出需要使用 ctrl+a x 这样的组合命令，注意是 ctrl+a 先一起按下去，然后按 x ，就可以看到 QEMU 模拟器被关闭，退回到 Linux 系统命令行。请大家注意不要随意使用其他的方法退出 QEMU ，可能会导致下一次 QEMU 启动失败。

\subsection{gdb调试}

gdb是功能强大的代码调试工具，RISC-V版本的gdb命令为riscv64-unknown-linux-gnu-gdb，已安装在我们的虚拟机环境中。输出该命令即可启动gdb。

在gdb命令行内输入target remote localhost:1234，即可与QEMU模拟器连接，连接成功之后QEMU模拟器的运行被暂停，需要在gdb这边手动继续运行。注意，使用target remote连接QEMU之前请确保QEMU模拟器已经启动。通过symbol-file main命令可以载入符号表，此处的main为编译生成的文件名称。（要求gcc编译时加上-g选项）

gdb的一些常用命令：

设置断点：\texttt{b}，后面跟上内存地址或代码中的行数，例：\texttt{b *0xa0800000}

继续运行：\texttt{c}

单步运行（单条汇编指令）：\texttt{si}

查看当前寄存器内容：\texttt{i r}

查看特定寄存器的值：\texttt{p \$a1} 或者 \texttt{p/x \$a1}

查看内存内容：\texttt{x}，命令格式：\texttt{x/nfu [addr]}

n是内存单元个数，f是显示格式，u是内存单元大小

显示指定地址之后的10条汇编指令：\texttt{x/10i addr}

显示指定地址之后的10条数据单元：\texttt{x/10x addr}

退出：\texttt{q}

以上只是一些基础的命令和使用例子，请大家自己搜索并使用gdb的各种功能，思考调试思路。


%\section{gitlab平台}

\section{附录：开发板内部细节}

本节将描述我们的实验平台的一些细节，帮助大家理解前面的一部分可能会使大家感到困惑的地方。

\subsection{概述}

PYNQ-Z2上并没有真实的RISC-V芯片，它是一个载有ARM核和FPGA芯片的开发板。既然PYNQ上面是个ARM核，那么，我们为什么可以在其上使用RISC-V核呢？秘诀就在于它载有的FPGA芯片。FPGA是可编程门控阵列的简称，可以用来模拟各种数字电路。我们向SD卡的第一个分区拷贝了BOOT.BIN文件，该文件包含了一个ARM核上的程序和RISC-V软核。开发板启动后，首先会运行BOOT.BIN。BOOT.BIN中的ARM程序会启动与初始化板上的ARM核，并在完成后将RISC-V软核烧到FPGA芯片上，然后启动RISC-V核。RISC-V核启动后会执行BBL，它会帮我们把SD卡上我们自己写的bootloader(也就是第三个分区的头512字节)载入到内存的指定位置，并将控制权移交，从而完成启动的过程。自行制作SD卡的流程参见\ref{subsec:make-sd-card}小节。

\subsection{制作可启动的SD卡\label{subsec:make-sd-card}}

在拿到裸的开发板和SD卡以后，需要将SD卡格式化为三个分区。第一个分区固定为34MB，采用fat32文件系统；第二个分区建议设定为 100 MB，采用 ext4 文件系统；剩余空间全部划入第三个分区，保持第三个分区为空分区。前两个分区用于PYNQ板上的ARM核的启动与初始化，第三个分区由RISC-V核使用。完成本步的SD卡制作后，在我们的后续实验中，只需对第三个分区进行修改。

在Linux系统下，可以使用fdisk工具对SD卡进行分区：

\begin{lstlisting}[language=bash]
// 非root用户请在前面加`sudo `
# fdisk /dev/sdb
// 此处/dev/sdb为你的SD卡设备名，可以使用lsblk命令确认设备名并自行参考修改

Welcome to fdisk (util-linux 2.34).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.


Command (m for help):
\end{lstlisting}

注意，如果你使用的Linux设置了中文，fdisk可能会输出中文提示信息，不影响操作。另外，根据机器上磁盘配置情况的不同,你可能需要自己选择正确的磁盘。比如，这里示例中SD卡设备是/dev/sdb，但在你的机器上可能是/dev/sda或/dev/sdc。sd代表磁盘，一般的机械硬盘和U盘（读卡器）都会被列入这里。如果你的机器（或虚拟机）有一块机械硬盘，则新插入的SD卡可能是/dev/sdb（因为sda一般是机器自己的机械硬盘）。一个简单的方法是，先执行ls /dev/sd*命令，然后插上读卡器再执行一遍这个命令，看多出来的是哪个。比如插上读卡器后多出来了一个/dev/sdb，那么显然，读卡器就是这个/dev/sdb；另一种方法是使用lsblk命令列出所有块设备，根据显示的容量确定SD卡的设备名。

创建第一个分区的过程如下：
\begin{lstlisting}[language=bash]
Command (m for help): o
Created a new DOS disklabel with disk identifier 0xae2c98d2.

Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p):

Using default response p.
Partition number (1-4, default 1):
First sector (2048-7626751, default 2048):
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-7626751, default 7626751): +34M

Created a new partition 1 of type 'Linux' and of size 34 MiB.

Command (m for help): n
Partition type
   p   primary (1 primary, 0 extended, 3 free)
   e   extended (container for logical partitions)
Select (default p): 

Using default response p.
Partition number (2-4, default 2): 
First sector (71680-30253055, default 71680):      
Last sector, +/-sectors or +/-size{K,M,G,T,P} (71680-30253055, default 30253055): +100M

Created a new partition 2 of type 'Linux' and of size 100 MiB.
\end{lstlisting}

在fdisk提示输入命令的时候按上面的示例输入。先输入o新建分区表，再输入n新建新分区，然后都默认就可以，只是大小必须为34M。随后再输入 n 新建分区，然后默认，并设置大小为100M。

接下来创建第三个分区，并把第一个分区类型改为fat32，第二个分区改为 Linux，第三个分区设置为 empty。最后按w写入并退出fdisk。

\begin{lstlisting}[language=bash]
Command (m for help): n
Partition type
   p   primary (2 primary, 0 extended, 2 free)
   e   extended (container for logical partitions)
Select (default p): 

Using default response p.
Partition number (3,4, default 3): 
First sector (276480-30253055, default 276480): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (276480-30253055, default 30253055): 

Created a new partition 3 of type 'Linux' and of size 14.3 GiB.

Command (m for help): t
Partition number (1,2, default 2): 1
Hex code (type L to list all codes): b

Changed type of partition 'Linux' to 'W95 FAT32'.

Command (m for help): t
Partition number (1,2, default 2): 2
Hex code or alias (type L to list all): 83

Changed type of partition 'Linux' to 'Linux'.

Command (m for help): t
Partition number (1-3, default 3): 3
Hex code or alias (type L to list all): 0
Type 0 means free space to many systems. Having partitions of type 0 is probably unwise.

Changed type of partition 'Linux' to 'Empty'.

Command (m for help): w
\end{lstlisting}

创建好分区后，首先需要为第一个分区制作文件系统。制作方法是用mkfs.vfat格式化第一个分区：

\begin{lstlisting}[language=bash]
# sudo mkfs.vfat -I /dev/sdb1 -n "BOOT"
\end{lstlisting}

随后为第二个分区制作 ext4 文件系统，制作方法是使用 mkfs.ext4 工具： 

\begin{lstlisting}[language=bash]
# sudo mkfs.ext4 -F /dev/sdb2 -L "ROOTFS"
\end{lstlisting}

以上两个分区的制作也请注意根据你自己的磁盘设备名情况调整sdb这个参数。

完成SD卡的分区制作以后，将预先提供的BOOT.BIN、boot.scr、image.ub拷入到第一个分区; rootfs.tar.gz 压缩包的内容解压到第二个分区，然后插入到开发板上，上电后就可以看到效果了。

\begin{note}
本材料中出现的shell中的\$和\#都代表命令行前面的提示符。\$代表普通用户，\#代表需要root权限。可以用sudo -i获得具有root权限的终端，而如果只需要以root权限执行某条命令，在命令前面加sudo即可。例如，如果想以root权限执行ls,则可以输入sudo ls。前面没加提示符的内容代表命令的执行结果。
\end{note}

\subsection{PYNQ内存地址空间情况}
PYNQ板上的内存地址空间情况如表\ref{tab:address-map}所示。其中，最需要注意的是，BBL所需的内存空间放置了BBL运行所需的数据和代码。请一定不要修改这段内存。BBL为我们提供了读写SD卡和输出字符串的相关服务。如果不小心修改了它的数据或代码，可能导致相关功能异常。

\begin{table}[htbp]
 \centering
\begin{tabular}{lll}
\toprule
地址范围                  & 权限   & 作用                   \\ \midrule
0x0-0x1000            & ARWX & debug-controller     \\
0x3000-0x4000         & ARWX & error-device         \\
0x10000-0x20000       & RX   & rom                  \\
0x2000000-0x2010000   & ARW  & clint                \\
0xc000000-0x10000000  & ARW  & interrupt-controller \\
0xe0000000-0xe0001000 & RWX  & serial               \\
0xe000b000-0xe000c000 & RWX  & ethernet             \\
0xe0100000-0xe0101000 & RWX  & mmc                  \\
0xf8000000-0xf8000c00 & RWX  & SLCR                 \\
0x50000000-0x50200000 & RWXC & memory(for BBL)      \\
0x50200000-0x60000000 & RWXC & memory               \\ \bottomrule
\end{tabular}
\caption{PYNQ内存地址空间\label{tab:address-map}}
\end{table}

我们自己编写的内核可以使用的内存空间为0x50200000-0x60000000这一段地址。

另外一点需要注意的是，如果错误地读写了0x0或者其他非memory的地址，那么很有可能触发中断。由于在前面阶段的实验中，我们没有设置中断处理机制，所以一旦访问错误的地址，在开发板上看到的现象就是程序卡死，不再继续执行。建议在调试的时候，多使用QEMU+gdb，或者分成小段一点一点调试。在出现内存相关的错误的情况下，试图直接找到大段代码中的错误很困难，应该一小段一小段逐步缩小范围，从而正确地找到错误的发生位置。

%\bibliographystyle{acm}
%\bibliography{guideref}
%\IfFileExists{chapters/0-basic.bbl}{\input{chapters/0-basic.bbl}}{\typeout{0-basic.bbl not found; run bibtex chapterone}}

\putbib[guideref]

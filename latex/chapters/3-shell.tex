\chapter{进程管理、通信与多核执行}
\begin{bibunit}[ieeetr]

\section{实验说明}
通过之前的实验，我们的操作系统已经具备任务调度与例外处理的功能，并且在用户态运行的进程已经可以通过系统调用接口去调用内核的代码（现在用户态和内核态的界限已经通过代码调用的一些限制体现了出来，这一界限将在后续的虚存中更好地体现出来）。

在这次实验中，我们将继续完善一些任务处理相关的功能，比如：进程的启动、杀死一个正在运行的程序、进程的正常退出、以及进程间的同步、通信等功能。更重要的是，我们将实现一个简单的终端，让我们的操作系统拥有一个简易的UI，交互性更强，真正可以“操作”。

% 我们的start code提供了一个大家可以在自己的代码基础上打补丁的程序。大家可以复制自己的Project 2文件夹，起名为Project 3，然后运行打补丁的程序。
% 有的文件可能无法自动打补丁，因此会报错，这些文件需要同学们自己手动把start code中的代码合并进来。具体的使用方法参见p3-autoupdate-patch文件夹的README文件。

本次的实验内容如下：

\begin{description}
    \item[任务一] 实现一个简易的终端，实现OS和用户的简单交互。实现一些终端命令以实现进程在终端上的启动、杀死、状态查询。

    \item[任务二] 了解屏障（barrier）、条件变量（condition variable）、mailbox这三种同步方式并实现其功能。

    \item[任务三] 实现多核的启动，并实现简单的程序多核并行执行及调度。

    % \item[任务四] 在上面mailbox功能的基础上，实现多核情况下的多进程同时收发信息。

    \item[任务四] 实现动态绑核的终端命令 \texttt{taskset}，从而实现动态的将进程绑定在某个核上。

    % \item[任务五] 实现细粒度锁的多核内核。
    
    \item[任务五] 实现简单的线程机制，解决多核mailbox的死锁问题。

    % \item [任务五] 多核下的 mailbox 处理
\end{description}

在上面的5个任务中，S-core的同学只需要完成任务一和任务二的屏障功能，A-core的同学需要完成任务一到任务三，C-core的同学需要使用双核完成全部五个任务。
下面将本Project的各个core需要完成的任务列成表格，请同学们在看完任务书之后再对应这个表格，确认需要完成的任务：

\begin{table}[H]
    \centering
    \begin{tabular}{ll}
        \toprule
        评分等级 & 需要完成的任务    \\
        \midrule
        S-core & shell终端及shell命令，barrier  \\
        A-core & 全部三种同步原语，通过双核测试 \texttt{multicore} \\
        C-core & \texttt{taskset}动态绑核命令以及mailbox 防死锁，并且双核通过所有的任务    \\
        \bottomrule
    \end{tabular}
    \caption{各个等级需要完成的任务列表\label{tab:core-list}}
\end{table}


\section{本章解读}

这一部分的要点是：

\begin{enumerate}
    \item 理解shell的作用及其简化的实现
    
    \item 理解实现进程通信和同步的多种方式
    
    \item 理解多核情况下操作系统的相关处理
\end{enumerate}
  
这一章其实是在完善我们的小系统。在之前的章节里，我们已经顺利地建立了进程管理和基本的锁。现在，我们要进一步扩展之前的功能，并允许用户进程之间进行交互。


\section{简易shell的制作和基础命令的实现}

为了方便我们接下来的任务运行和测试，我们要求同学们在本次任务完成一个小型shell的制作。
这个终端可以实现用户命令的输入，用户命令的解析，最终根据用户命令的内容，调用内核相关的系统调用。

对于一个终端的定义，在传统的操作系统是比较复杂的。
但考虑到任务的难度，我们在这里简化了终端的定义。
大家可以简单的认为，我们这里要实现的终端就是\textbf{一块屏幕（screen）}、\textbf{一个可以解析命令的进程（shell）}。

\subsection{一块屏幕（screen）}

所谓的一块屏幕，我们在Project 2的时候就已经用到过了。
它实际上就是用我们提供给大家的screen库函数来进行操作的。在本次实验大家不需要考虑这部分的具体实现，使用库printf将内容打印在屏幕上即可，但是需要补全一些代码。
还需要注意cursor的信息，在Project 2的时候大家可能已经注意到了，cursor决定了输出在屏幕上的位置。

\subsection{一个可以解析命令的进程（shell）}
shell本质上其实是一个进程，只不过它的功能比较特殊，它负责用户和内核的交互。
再具体的说，shell负责从用户读取命令，将命令传递给内核执行，并将结果反馈给用户。
我们从命令的执行流程来分析shell的功能：

\begin{enumerate}
    \item 从输入流读取数据，这里的数据流实际上就是串口输入，关于串口输入的读取，我们在本次实验中已经给大家提供了现成的函数，大家直接用就可以了。
    
    \item 读取到了命令后，shell要做的就是解析，根据用户的输入判断用户要执行什么命令，如果输入有效就调用内核相关的系统调用。
    
    \item 最后，用户输入了一串字符串，shell进程虽然读到并解析了，但是并没有打印到屏幕上，用户也看不见，因此shell需要将读取到的字符串打印到屏幕上。
\end{enumerate}

串口输入函数由BIOS提供，函数名为\texttt{bios\_getchar}，在Project 1的时候大家已经用过\cite{zynq7000-tr}。请大家将其封装为系统调用以后在实现shell的时候使用。


\subsection{任务1：终端和终端命令的实现}

\subsubsection{实验要求}

请实现以下功能：

\begin{itemize}
    \item 可以实现用户命令输入的读取、解析、显示，根据用户输入调用相关系统调用。支持对输入的删除（完成对退格键的支持）。
    
    \item 分开显示该终端启动的任务输出和用户的命令输入。
    
    \item 实现ps (process show) 命令，实现系统调用\texttt{sys\_ps}，在终端输入\texttt{ps}可以打印出正在运行的任务列表。
    
    \item 实现clear命令，输入\texttt{clear}可以实现清屏。
    
    \item 实现对无法识别的命令的处理，输出 \texttt{unknown command} 报错并返回到shell命令提示符
\end{itemize}

最终效果的参考图\ref{fig:p3-demo}，\textbf{下半屏幕用于shell的输入输出}，\textbf{上半屏幕用于测试用例的输出}：

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{p3-demo}
  \caption{最终效果示例\label{fig:p3-demo}}
\end{figure}

除了上述的需要要实现的功能，同学们还可以根据自己的理解去完善，比如实现滚屏等额外的功能。

%\subsubsection{文件介绍}

%请同学们在Project 2的基础上添加Project 3的实现。我们需要使用的测试文件如表\ref{tab:p3-files}所示。
%\begin{table}[htbp!]
%\begin{tabularx}{\textwidth}{llX}
%\toprule
%   & 文件名                                          & 说明                                   \\ \midrule
%1  & test/project3/test3.h                        & Project 3的测试头文件                       \\
%2  & test/test\_shell.c                           & 任务一的相关框架，补充其内容完成任务一                  \\
%3  & test/project3/test\_kill.c                   & 测试任务一的完成，测试spawn、exit、kill、wait      \\
%4  & test/project3/test\_semaphore.c              & 测试任务二的完成，测试信号量（semaphore）            \\
%4  & test/project3/test\_condition.c              & 测试任务三的完成，测试条件变量（condition variables） \\
%5  & test/project3/test\_barrier.c                & 测试任务二的完成，测试屏障（barrier）               \\
%6  & test/project3/test\_mailbox.c                 & 测试任务二的完成，测试进程通信                      \\ \bottomrule
%7  & test/project3/test\_
%8  & include/os/cond.hkernel/locking/cond.c       & 任务三的条件变量实现                           \\
%9  & include/os/sem.hkernel/locking/sem.c         & 任务三的信号量实现                            \\
%10 & include/os/barrier.hkernel/locking/barrier.c & 任务三的屏障实现                             \\
%11 & lib/mailbox.clib/mailbox.h                   & 任务四的进程通信实现                           \\
%12 & drivers/screen.cdrivers/screen.h             & 虚拟屏幕的实现                              \\ \bottomrule
%\end{tabularx}
%\caption{Project 3 文件列表\label{tab:p3-files}}
%\end{table}


\subsubsection{注意事项}

\texttt{test/shell.c}文件中要实现shell的相关处理操作。
shell在本次实验中担任着启动所有任务的角色，因此我们应该在内核初始化之后，就把shell启动起来，将它作为pid号为1的第一个用户态进程。

此外，shell输入应支持退格键，在输入错误时用退格键删除之前的输入，这需要同学们补全\texttt{screen.c}中\texttt{screen\_write\_ch}的代码。

%\subsubsection{要点解读}
%对于RISC-V版本来说，我们需要调用SBI里面提供的sbi\_console\_getchar()来获得用户输入。
%为了系统的灵活性，这个SBI不保证一定能读到键盘的内容。
%也就是说，如果用户输入了，我们就能得到用户的输入。
%如果在调用该函数时，串口中没有收到任何用户的输入，则sbi\_console\_getchar()会直接返回-1。

%这里再稍微解释一下串口的工作原理。
%以PYNQ-Z2板子上的串口为例，板子上的串口为Xilinx PS UART\cite{zynq7000-tr}。
%它内部有一个FIFO队列，读写的数据都会进入到该队列中。用户敲击键盘发送的内容会被硬件自动放入到队列中。
%此时，如果我们读取硬件的FIFO寄存器，读到的内容就是读队列的第一个字符。
%读了以后，硬件会自动把第一个字符弹出队列，再读就是下一个字符了。
%如果FIFO队列为空，也就是没有未被处理的用户键盘输入时，串口的状态寄存器会指示FIFO为空。
%看到FIFO为空时，sbi\_console\_getchar()会返回-1。

%由于sbi\_console\_getchar()可能会返回-1（因为用户输入相对于函数调用来说慢太多，所以很可能多数情况都是返回-1的），
%所以建议可以封装一个类似于C库的getchar()一类的函数（可以实现在我们的tiny c库中）。该函数不断调用系统调用，通过系统调用来进一步调用sbi\_console\_getchar()，从而获得用户输入。假如输入是-1则继续循环，否则返回读到的字符。

在实现\texttt{getchar}功能的时候建议将字符读入到一个小的buffer中，等到用户按回车键时，判断buffer中的内容，是否是某个命令。
对于每个命令分别设置相应的处理函数，实现该命令的功能。
使用小buffer的原因是用户可能会输入退格键，直接试图根据输入的字符做个状态机解析可能会比较麻烦。
等输入完了再解析稍微省事一点。%解析不用很复杂，可以直接判断buffer的开头是不是某个命令就好了。

自己测试的时候，能够看到输入的回显（这个也需要自己写），能够输入并解析些简单命令就可以进入下一节的内容了。

S-core的同学，由于在P2中没有实现定时器中断，因此需要注意shell在使用\texttt{while}循环反复试图获取终端字符时，会阻止其他进程的执行，因此需要实现一个机制，让shell在一段时间都获取不到输入时主动放弃执行。

\subsection{进程的创建和退出}
在之前实现中，我们对一个任务的创建是放在\texttt{init\_pcb}中，也就是初始化PCB里，并没有单独的系统调用去完成一个任务的创建，并且我们的任务一旦运行起来是无法正常退出的。
因此，在本次实验我们将完成任务的创建方法（exec）、退出方法（exit），以及杀死一个任务的方法（kill），等待一个任务的方法（waitpid），并为之封装系统调用，其中S-core的exec实现要求与A/C-core不同，约定如表\ref{tab:p3-interface}所示。

\begin{table}[!htbp]
    \begin{tabularx}{\textwidth}{lX}
        \toprule
        函数签名 & 分S-core与A-core \\
        \midrule
        S-core  & \texttt{pid\_t sys\_exec(int id, int argc,  uint64\_t arg0, uint64\_t arg1, uint64\_t arg2)} \\
        参数说明 & \texttt{id}为任务的id，\texttt{argc}为传递给任务的参数个数，在该接口中最多有三个，\texttt{arg0/1/2}分别对应三个参数 \\
        A/C-core  & \texttt{pid\_t sys\_exec(char *name, int argc, char **argv)} \\
        参数说明 & \texttt{name}为任务的名称，\texttt{argc}为命令行传入参数的总个数，\texttt{*argv[]}是一个指针数组，里面存放的指针指向对应的命令行参数 \\
        功能   & 启动一个新的进程 \\
        返回值 & 成功返回新启动进程的pid，失败返回0 \\ 
        \bottomrule
        \\ \\

        \toprule
        函数签名 & \texttt{int sys\_kill(pid\_t pid)} \\
        \midrule
        参数说明 & \texttt{pid}为需要被kill的进程的pid \\
        功能   & 杀死指定进程，回收分配给它的资源 \\
        返回值 & 成功时返回1，找不到对应pid的进程返回0 \\
        \bottomrule
        \\ \\

        \toprule
        函数签名 & \texttt{void sys\_exit(void)} \\
        \midrule
        功能   & 退出当前任务，并回收当前任务的资源 \\
        \bottomrule
        \\ \\

        \toprule
        函数签名 & \texttt{int sys\_waitpid(pid\_t pid)} \\
        \midrule
        参数说明 & \texttt{pid}为需要等待的进程的pid \\
        功能   & 等待对应pid的进程程执行完毕。 \\    
        返回值 & 返回等待进程的pid，如果不存在对应pid的进程则返回0 \\
        \bottomrule
    \end{tabularx}
    \caption{接口约定\label{tab:p3-interface}}
\end{table}

\subsection{任务1续：exec、kill、exit、waitpid方法的实现}
\subsubsection{实验要求}
完成exec、kill、exit、wait的系统调用，通过我们给定的测试集。

\subsubsection{文件介绍}
本实验请大家根据自己之前的代码继续实现。

\subsubsection{实验步骤}

\begin{enumerate}
    \item 实现上述的四种内核方法：exec、kill、exit、wait，并为其封装系统调用后方可进行测试集的运行。

    \item 请大家先仔细阅读本任务的注意事项后再开始本次任务。

    \item 本次实验实现的exec命令对不同的等级要求不同，对于S-core而言需要实现exec [id]命令的解析；A/C-core的同学需要实现 \texttt{exec [name]} 命令的解析：
    比如用户输入 \texttt{exec waitpid}，则启动 waitpid 任务。对于 A/C-core 的 exec 命令，我们还需要大家实现一个小的附加功能：shell在成功加载对应的进程并获得其pid之后，
    默认执行\texttt{sys\_waitpid}等待该进程执行完毕。并且支持加上\&选项使得shell不用等待新加载的进程执行完毕。其实只需要大家在解析用户输入命令时判断是否带有\&选项并调用\texttt{sys\_waitpid}即可，本次
    实验中所有的任务都以这样的方式启动运行。如图\ref{fig:p3-exec}所示。

    \begin{figure}[!htbp]
      \centering
      \includegraphics[width=0.8\textwidth]{p3-exec}
      \caption{输入 \texttt{exec {waitpid} \&} 启动waitpid任务\label{fig:p3-exec}}
    \end{figure}

    \item S-core通过 \texttt{exec [id]} （id为waitpid任务的id）；A/C-core 的同学通过 \texttt{exec waitpid \&} 启动waitpid任务，该任务的描述见表\ref{tab:p3-task1-3}。

    \item 实验成功的结果如图\ref{fig:p3-result1}所示。

    \begin{figure}[!htbp]
      \centering
      \includegraphics[width=0.8\textwidth]{p3-result1}
      \caption{启动后最后一个任务会等待第一个任务的退出\label{fig:p3-result1}}
    \end{figure}

    \item 在shell中实现 \texttt{kill [pid]} 命令的解析：允许用户终止某个进程的运行。如果进程被kill之后持有锁，需要释放内核管理的相关资源。
\end{enumerate}

% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[!htbp]
    \begin{tabular}{lp{30em}}
        \toprule
        任务 & 描述 \\
        \midrule
        \texttt{ready\_to\_exit} & 申请两把锁，过一段时间后退出。 \\
        \texttt{wait\_lock}      & 
            请求task1获得的一把锁，但是由于task1占用该锁，task2会被阻塞并打印出 \texttt{"I want to acquire a mutex lock from task."}。\newline{} 直到task1退出任务后释放该锁，task2会继续执行，打印出 \texttt{"I have acquire a mutex lock from task"} 后退出。 \\
        \texttt{wait\_exit}      & 
            启动\texttt{ready\_to\_exit}和\texttt{wait\_lock}两个任务。并将第一个任务的pid传给第二个任务 \newline{}
            调用\texttt{sys\_waitpid}系统调用函数，等待task1退出。task1退出后会继续执行，打印出 \texttt{"task has exited"} 后退出。 \\
        \bottomrule
    \end{tabular}
    \caption{waitpid任务说明\label{tab:p3-task1-3}}
\end{table}

\subsubsection{注意事项}

\begin{itemize}
    \item 对于做S-core的同学，由于我们无法确定对应任务的id，因此需要自己按照提示修改 \texttt{./test/test\_project3/waitpid.c} 文件中传递给 \texttt{sys\_exec} 的任务id。此外在编译时需要将\texttt{Makefile}文件中的 \texttt{"CFLAGS"} 开头的一行末尾添加 \texttt{-DS\_CORE"} ，以启用S-core版本的测试代码，未来的实验中也会继续沿用。
    
    \item 本实验要求通过 \texttt{exec} 启动的新任务可以接受参数，既然用户进程是操作系统来创建的, 很自然参数的传递就需要由操作系统来负责。此处的实现对于 S-core 和 A/C-core 也有不同的要求。
    
    \textbf{S-core}：对于S-core而言，为了降低难度，我们要求大家实现简单的参数传递，需要shell解析之后直接将数值传递给内核，由内核将数据填入初始化进程相应的上下文寄存器，并且需要注意在跳转到用户程序main函数执行之前不要破坏相应的寄存器中的值。
    想必大家也注意到了，受到寄存器数量的限制，这样的方式传递的命令行参数数量是有限的，并且只支持传递一个数值，不够灵活。因此我们鼓励大家尝试实现A/C-core的命令行参数。
    
    \textbf{A/C-core}：对于A/C-core而言，我们要求大家实现较为标准的命令行参数，也就是大家在程序设计课上学习过的\texttt{argc}和\texttt{argv}，最适合存放命令行参数的地方就是用户栈了， 
    因为在首次切换到用户进程的时候, 用户栈上的内容就已经可以被用户进程访问。 于是操作系统在加载用户进程的时候, 还需要负责把\texttt{argc/argv}以及相应的字符串放在用户栈中，在我们的实验中由shell执行\texttt{sys\_exec}时，将命令行参数传递给操作
    系统，由操作系统系统将其拷贝到新打开的进程的栈上。因此我们需要在初始化进程时在用户栈上开辟出一部分空间来保存命令行参数信息（包括指针数组\texttt{argv}和其指向的命令行参数），具体的格式可以参考图\ref{fig:user-stack-cmdargs}，（
    应用传递了两个命令行参数\texttt{"aa"}和\texttt{"bb"}，该图把这些参数分成两部分, 一部分是字符串区域, 另一部分是\texttt{argv}字符串指针数组, 数组中的每一个元素是一个字符串指针, 而这些字符串指针都会指向字符串区域中的某个字符串），
    此外，为了实现的简单我们建议大家在初始化进程上下文时将命令行参数的个数（\texttt{argc}）和指针数组的地址（\texttt{argv}）分别放到新进程上下文的\texttt{a0}和\texttt{a1}寄存器中，这样就可以在进入到用户程序的\texttt{main}函数时使用了，需要注意在跳转到用户程序\texttt{main}函数执行之前不要破坏
    这两个寄存器的值。
    
    \begin{figure}[!htbp]
      \centering
      \includegraphics[width=0.5\textwidth]{user-stack-cmdargs}
      \caption{命令行参数参考布局图\label{fig:user-stack-cmdargs}}
    \end{figure}
    
    \item 在实验中，需要注意一个细节RISC-V 的 ABI\cite{riscv-elf} 要求栈指针的地址是 128 bit 对齐的。在启动用户进程的时候建议大家遵循这一点，以免出现意料之外的问题。
    
    \item 本次任务，虽然看起来比较直观，但是需要注意的细节很多，特别是在一个任务退出时需要将其占有的资源全部释放，比如：栈空间、pcb等。
    
    \item pid是由\texttt{sys\_exec}返回的，进而通过\texttt{sys\_exec}传递给第二个进程。因此，这里不需要特意让某个进程的pid是某个预设好的值。
\end{itemize}

%\subsubsection{要点解读}
%基本上，到这一章为止，我们的小系统就有一个基本的操作系统的样子了。由内核启动第一个进程（也就是我们的test\_shell），然后再进一步由该进程启动其他的线程。

%和MIPS版本相比，RISC-V版修正了这样一个问题：进程没有ZOMBIE状态。可能知识渊博的你以前听说过ZOMBIE状态，但也许你对于为什么会有这样一个状态没有头绪。很多书上也不会提及这个状态。实际上是这样的，假设task2调用waitpid，等待task1退出。这时，有两种可能性，一种是task2先调用了waitpid，然后task1退出。另一种是，task1已经退出了，然后task2调用了waitpid。对于传统的UNIX来说，waitpid一类的动作是可以拿到task1的返回值的。所以，这里task1即使已经提前退出了，但还不能把它清理掉。否则，waitpid就无法拿到它的返回值了。需要等有人waitpid拿到它的返回值，才能清理掉。一般如果父进程退出时没有waitpid子进程，那么子进程会被过继给init进程（也就是第一个进程），由它负责定期清理。

%这样设计还有一个原因，在多内核栈的设计中，子进程是难以回收自己的内核栈的。原因是，子进程调用sys\_exit函数退出，此时，sys\_exit运行在该进程的内核栈上。因而，在sys\_exit执行完毕前，该进程的内核栈一直是被sys\_exit使用的状态。但sys\_exit执行完成后，子进程就彻底退出了。所以子进程没有机会回收自己的内核栈，只能由别的进程代劳。在常见的类UNIX系统的设计里，子进程退出后进入ZOMBIE状态，父进程调用waitpid系统调用等待子进程退出（waitpid运行在父进程的栈上），子进程退出后，父进程取走子进程的返回值，顺便就可以帮子进程回收它的所有资源（此时运行在父进程的内核栈上，而不是子进程的内核栈上，所以完全可以回收子进程的内核栈）。

%这里我们做的简单一点，不需要过继给父进程这么复杂了。如果希望对某个进程做waitpid，就在spawn的时候设置为ENTER\_ZOMBIE\_ON\_EXIT。这样，sys\_exit时，就会进入ZOMBIE状态，等待父进程waitpid并回收资源。如果设置为AUTO\_CLEANUP\_ON\_EXIT，退出时将自己交给内核（也就是第一个进程，或者一个自己编写的专门用于回收资源的内核线程也可以），由它来负责清理。当然，如果感兴趣，也可以完整实现一个存在父子进程关系的版本。

%另外需要注意，由于需要回收资源，所以需要大家自己修改mm.c实现回收内存页的功能。可以仿照实验二提供的timer那个框架里面的分配和回收timer对象的方式，把回收回来的放在一个free list里面。再有需要的时候就再次分配出去。

\section{同步原语}

在Project 2的时候，我们实现了进程的运行和调度，但是两个进程之间如果需要进行同步，则需要比较复杂的机制。
例如我们在Project 2里面实现的锁，通过操作系统提供的锁服务，两个进程可以对某个临界区数据进行保护，并分别进行访问和操作。
而在这一节的内容中，我们将介绍几种常见的同步原语，并由同学们在自己的操作系统中实现它们。

值得一提的是，就做到Project 3的现实情况而言，我们这里依然很难清楚的在操作系统里面区分进程和线程的概念。
这是因为我们现在还没有实现内存空间的隔离和虚拟内存管理，进程之间使用完全隔离的内存空间这一特性很难体现。
所以要强调的是，研讨课这里只是为了简化线程和进程的区别，实际上它们两者的区别还是希望大家通过理论课的学习和后续研讨课Project 4的内容来扎实的理解。
到Project 3为止我们依然希望大家类似Project 2的情况，通过代码调用来体现进程之间的隔离。

此外，目前我们的框架中并不支持原有的\texttt{atomic\_cmpchg}和\texttt{atomic\_cmpxchg\_d}原子操作。我们已经在新框架中将其注释，请大家注意查看。


\subsection{屏障（barriers）}
这一节开始我们介绍我们要实现的各种同步原语，首先从屏障开始，barriers是一种同步机制，
一组进程的 Barrier 可以用来同步该程序组，只有当该程序组中所有进程到达屏障点（可称之为同步点）时，所有程序才得以继续执行。

屏障可以告诉一组进程在什么时候完成了各自的任务可以接下来进行其他的工作，即一旦所有的进程都到达了屏障点，它们才能够继续执行下去，
否则先到达屏障点的进程就会在此处等待其他进程的到来，因此屏障操作是一个相当重量级的同步操作。

\subsection{条件变量（condition variables）}
条件变量是一种同步机制，允许进程挂起，直到共享数据上的某些条件得到满足，用于多线程之间的通信。
条件变量上的基本操作有：触发条件(当条件变为 true 时)；等待条件，挂起线程直到其他线程触发条件。

条件的检测是在互斥锁的保护下进行的。
如果一个条件为假，一个进程自动阻塞，并释放互斥锁。
如果另一个进程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的进程，该进程重新获得互斥锁，重新评价条件。

% \subsection{信号量（semaphores）}
% %\subsubsection{为什么使用信号量}
% %为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，在任一时刻只能有一个执行线程访问代码的临界区域。我们把对共享内存进行访问的程序片段称为临界区域或临界区，而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。
% \subsubsection{信号量的定义}
% 信号量的本质是一种数据操作锁，它本身不具有数据交换的功能，而是通过控制其他的通信资源（文件，外部设备）来实现进程间通信，它本身只是一种外部资源的标识。
% 信号量在此过程中负责数据操作的互斥、同步等功能。

% 当请求一个使用信号量来表示的资源时，进程需要先读取信号量的值来判断资源是否可用。
% 大于0，资源可以请求；等于0，无资源可用，进程会进入睡眠状态（进程挂起等待）直至资源可用。
% 当进程不再使用一个信号量控制的共享资源时，信号量的值+1（信号量的值大于0），对信号量的值进行的增减操作均为原子操作，这是由于信号量主要的作用是维护资源的互斥或多进程的同步访问。而在信号量的创建及初始化上，不能保证操作均为原子性。

% 信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。
% 最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。
% %
% \subsubsection{信号量的使用方法}
% 由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：

% P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行

% V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.

% 举个例子，两个进程共享初始值为1的信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。
% 而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。

% \begin{note}
% 独门绝技：如何用pv操作实现同步和互斥？互斥比较好实现，两个线程互斥执行就是用pv操作实现一个mutex。两个线程同时用p来抢锁，然后出了临界区用v解锁。同步指我希望让某一段先运行，另一段后运行。比如我希望线程A先执行完，再让线程B开始执行它的代码。那么，做法应该是线程A结束的时候做V操作给sv+1，线程B开始的时候做P操作抢sv，而sv初始化为0个。这样就必须A先做完以后通过V操作让sv大于0，然后线程B才能够执行p操作。只要是想让某一段代码先于另一段执行，都可以用这种技巧实现。
% \end{note}

\subsection{任务2：实现同步原语：barriers、condition variables}
\subsubsection{实验要求}
了解操作系统内进程间同步的机制，学习和掌握壁垒（barriers）和条件变量（condition variables）的原理和实现方法。
针对这些同步原语，我们要求实现start code中的相关函数。做S-core的同学只需要完成barriers。

\subsubsection{文件介绍}
请基于任务1的代码继续进行实现。

\subsubsection{实验步骤}
\begin{enumerate}
\item 实现condition variables、barriers的内核代码并为之封装系统调用。
\item 请大家仔细阅读注意事项后再开始本次任务
\item 屏障测试：对于S-core而言shell输入 \texttt{exec [id]}，\texttt{id}为barrier任务的id；对于A/C-core而言shell输入 \texttt{exec barrier \&} 启动barrier测试任务，该测试是三个进程不停的进入屏障，只有当3个进程都达到屏障后才会解除阻塞，进行下一轮的进入。如果只有两个进程达到屏障，那么它们会被阻塞，直到第三个达到屏障。\textbf{由于屏障的存在，三个进程打印出的循环次数应该是一起增长的}。如图\ref{fig:p3-barrier}所示。
% \item semaphores 测试：该测试是使用信号量实现简单的生产者、消费者模型，不考虑生产溢出的情况。使用exec启动semaphore任务。该任务任会创建一个初始值为15的信号量，由3个进程对其进行P操作，各15次，由3个进程对其进行V操作，各10次。
% 最终，当三个任务运行完成退出后，如果实现正确，可以看到各个进程进行P操作10次或V操作15次。运行过程中消费总数比生产总数多15，如图\ref{fig:p3-sema}所示。
% 测试进程的行为如表\ref{tab:p3-task-semaphore}所示。
\item 条件变量测试：shell输入 \texttt{exec condition \&} 启动condition variables测试任务，这个测试是一个基于条件变量实现的简单而经典的生产者消费者模型，感兴趣的同学可以看代码了解一下实现。其中测试程序会启动一个生产者进程负责生产产品，之后再启动多个消费者进程负责消费产品。当然，如果你的条件变量实现正确，\textbf{那么生产者产生的商品总数是和消费消费的商品总数是一样的}，如图\ref{fig:p3-condition}所示。为了确保正确性，线程会睡眠随机长的时间，从而模仿每个消费者的速度不同的情况。
\end{enumerate}

% \begin{table}[!hbtp]
% \begin{tabularx}{\textwidth}{lX}
% \toprule
% 任务入口 & 功能\\
% \midrule
% \textbf{semaphore\_add\_task1} & 每次对临界区的值+1，一共进行10次\\
% \textbf{semaphore\_add\_task2} & 每次对临界区的值+1，一共进行20次\\
% \textbf{semaphore\_add\_task3} & 每次对临界区的值+1，一共进行30次\\
% \bottomrule
% \end{tabularx}
% \caption{task\_test\_semaphore任务说明\label{tab:p3-task-semaphore}}
% \end{table}

%\begin{figure}[!htbp]
%  \centering
%  \includegraphics[width=0.8\textwidth]{p3-cond}
%  \caption{生产者消费者模型\label{fig:p3-cond}}
%\end{figure}

\begin{figure}[htbp]
    \begin{minipage}[t]{0.5\linewidth}
        \centering
        \includegraphics[width=0.95\textwidth]{p3-barrier}
        \caption{测试barrier\label{fig:p3-barrier}}
    \end{minipage}%
    \begin{minipage}[t]{0.5\linewidth}
        \centering
        \includegraphics[width=0.95\textwidth]{p3-condition}
        \caption{测试condition variables\label{fig:p3-condition}}
    \end{minipage}
\end{figure}

% \begin{figure}[!htbp]
%  \centering
%  \includegraphics[width=0.8\textwidth]{p3-sema}
%  \caption{测试信号量的功能\label{fig:p3-sema}}
% \end{figure}


\subsubsection{注意事项}

\begin{enumerate}
    \item S-core的同学按照提示修改 \texttt{./test/test\_project3/S\_CORE/barrier.c} 文件中传递给\texttt{sys\_exec}的任务id。

    \item 同步原语是操作系统中的一个重要部分。针对不同的场景，可以选择合适的同步原语进行使用，它们的本质都是对临界区的保护，实现进程间的同步。
\end{enumerate}

%\subsubsection{要点解读}
%对于RISC-V来说，本次任务的难点在于所有的同步原语都是在用户态实现的，这个和pthread库是一样的，但相较于MIPS全部在内核态实现来说，难度要高一些。
%因为用户态随时可能被打断，如何保证语义的正确性，实际上是需要细致考虑的。

%MIPS把所有的功能实现在内核态，而用户态只是负责调用某个对象，这样做简化了同步原语本身的实现。但这种做法大家往往设计的漏洞很多。正确的设计下，同一个同步原语应该需要设计两套定义。一套是内核中真正的定义，包含阻塞队列及必要的辅助变量。另一套是用户态的，应该只是一个对象id。每次init的时候通过系统调用申请一个内核对象，然后让内核把对象的id返回来。用户态只能看到id，不能看到内核维护的具体的结构。不过多数同学实现的时候会有意无意的忽略不能让用户态看到内核态的敏感数据这一原则，直接把包括阻塞队列在内的很多敏感内容放置在用户态中。针对此，RISC-V版本索性就直接选择让大家实现一个用户态内核态协同的版本，由敏感数据内核管理，其他的锁相关的辅助变量放在用户态。但相应的，需要原子指令等复杂操作来完成整个逻辑，而且该逻辑想设计正确比较烧脑。

%当然，RISC-V版本同样也可以选择实现在内核态。但注意用户态一定不能看到内核管理的敏感数据。这里给一个简单的参考思路（以barrier对象为例）：
%\begin{lstlisting}[language=c]
%typedef struct list_barrier{
%    int id;
%    barrier_t *obj;    // the allocated object
%    list_node_t list; // link field
%}list_barrier_t;
%struct pcb{
%  // 增加一个list记录都给它分配了哪些barrier对象
%  list_barrier_t barriers;
%};
%// 定义一组系统调用
%// 从内核中分配一个barrier对象，把分配的对象插入到pcb相应链表里，然后把id返回给用户态
%int sys_alloc_barrier(); 
%// 用户态的barrier定义
%struct barrier {
%  int id;
%}
%// 其他系统调用都传递这个id作为参数
%//内核态下，通过id查找pcb中记录的list里面的对应对象，然后对该对象执行barrier_wait操作。
%void sys_barrier_wait(int id); 
%\end{lstlisting}

\subsection{mailbox通信}
%\subsection{生产者——消费者模型}
在本节，大家将实现更复杂的一种通信方式mailbox，通俗的而言就是一个类似于信箱的东西，发送方将信息存到信箱里，接收方从信箱里取出信息，这样就实现了进程间的通信。
%如图\ref{fig:mailbox}所示。

%\begin{figure}[!htbp]
%  \centering
%  \includegraphics[width=0.8\textwidth]{mailbox}
%  \caption{mailbox通信原理\label{fig:mailbox}}
%\end{figure}

具体来说，所谓的mailbox通信就是为两个任务建立一个公共的临界区，进程1把想发送给进程2的数据放到里面，进程2再从里面拿出来，这样就完成了一次进程的通信。
虽然听起来似乎很简单，但其实想实现出来也需要考虑很多问题，比如：如果一个任务想往临界区放数据，但是临界区空间不足了怎么办？
如果一个任务想从临界区读数据，但是临界区空了怎么办？临界区肯定存在同时被多个进程访问的情况，如何保证访问的原子性？


因此在本章节，同学们将实现一个mailbox通信功能去实现进程间的通信，同时保证数据的一致性。
当然请大家注意，这一节我们强调的是进程间的通信，也就是说我们不允许两个进程之间共享同一个变量或者内存地址。
所以向其他进程的信箱发送信息或接收自己信箱的信息应该使用信箱的名字而非信箱的变量。操作系统才是那个根据信箱名字来真正投递信件或返回信件内容的实体。

\subsection{任务2续：进程间的通信------mailbox实现}

\subsubsection{实验要求}

实现进程间的通信，使用之前实现的同步原语去保证临界区的正常访问，并通过我们给出的测试集。
关于进程通信的接口申明，已经写在了\texttt{tiny\_libc/include/unistd.h}中，请同学们根据接口进行实现。表\ref{tab:mailbox-interface}为接口的描述。

\begin{table}[!hbtp]
    \begin{tabularx}{\textwidth}{lp{15em}X}
        \toprule
        & 函数名 & 说明\\
        \midrule
        1 & \texttt{sys\_mbox\_open(name)} &
        根据名字返回一个对应的mailbox，如果不存在对应名字的mailbox，则返回一个新的mailbox。\\
        2 & \texttt{sys\_mbox\_close(mbox\_idx)} &
        关闭mailbox，如果该mailbox的引用数为0，则释放该mailbox。\\
        3 & \texttt{sys\_mbox\_send(mbox\_idx, msg, msg\_length)} &
        向一个mailbox发送数据，如果mailbox空闲空间不足，则产生一个阻塞，直到把数据放进去。\\
        4 & \texttt{sys\_mbox\_recv(mbox\_idx, msg, msg\_length)} &
        从一个mailbox接收数据，如果mailbox没有足够的数据，则产生一个阻塞，直到读到数据。\\
        \bottomrule
    \end{tabularx}
    \caption{mailbox接口约定\label{tab:mailbox-interface}}
\end{table}

\subsubsection{文件介绍}

请继续之前的代码继续完成。

\subsubsection{实验步骤}

\begin{enumerate}
    %\item 在进行测试时请确保之前实验的系统调用都已经实现了，包括：sys\_sleep、sys\_spawn、sys\_kill、sys\_waitpid。

    \item 完成IPC相关接口实现。

    \item 本次的测试任务为\texttt{mbox\_server}和\texttt{mbox\_client}，\texttt{mbox\_client}为客户端，测试时会启动多个，\texttt{mbox\_server}为服务端，只启动一个。首先shell输入 \texttt{exec mbox\_server \&} 启动mailbox服务端，随后输入 \texttt{exec mbox\_client \&} 依次启动客户端。
\end{enumerate}

对于本次的测试，我们准备一个复杂的测试场景。
两个或更多的进程为发送mail的进程，一个进程为接收mail的进程。发送mail的进程不断的发出长度随机的字符串，而接收mail的进程要不断的将从mailbox中接收到的的字符串长度打印出来。
由于发送进程也会打印自己发送的长度，因此接收进程收到的字符串长度应等于所有发送mail进程发出的字符串长度总和。并且我们还模仿网络包添加了校验功能，可以从\texttt{mbox\_server}打印的errorBytes判断传递的信息是否正确。

由于多个进程在同时向同一个进程的mailbox里面发送字符串，因此到了一定时间之后接收进程的mailbox就会满，此时则发送就会失败。
注意发送失败的具体判断条件应为要发送的字符串长度大于mailbox的剩余空间长度。

%我们设计了一个有趣的小场景：现在有三个人（进程），它们分别是刘备、孙权、曹操（如图\ref{fig:p3-sanguo-master}所示）。

%\begin{figure}[!htbp]
%  \centering
%  \includegraphics[width=0.8\textwidth]{p3-sanguo-master}
%  \caption{刘备、孙权和曹操\label{fig:p3-sanguo-master}}
%\end{figure}

%曹操是个大BOSS，它会干掉（kill）任何他看到的人（进程），每一次行动，曹操都会选择刘备或者孙权中的一个去下手（对其执行kill）。
%而刘备和孙权为了防止被曹操一个一个干掉，达成了一个合作条约：它们相互监（waitpid）听对方的状态，一旦发现对方有被曹操干掉，马上前去救助（spawn）。

%如此一来，曹操每次干掉一个人，另外一个人都会马上前去救助（spwan），这样场面上一直会是“三足鼎立”的局面（如图\ref{fig:p3-sanguo-rel}所示）。

%刘备和孙权每次被干掉后救起，都会重新发送（mbox\_send）自己的信息（pid）给对方，对方也会接收（mbox\_recv）到对方的新信息，
%当然，这个信息也会被曹操所窃取，曹操会根据信息执行下一次的计划（kill）。

%\begin{figure}[!htbp]
%  \centering
%  \includegraphics[width=0.8\textwidth]{p3-sanguo-rel}
%  \caption{三足鼎立\label{fig:p3-sanguo-rel}}
%\end{figure}

%如果“三足鼎立”局面成立，你会发现无论曹操干掉刘备孙权中的哪一个，另外一个都会大喊着“XXX I’m coming to save you！”去把被干掉的人救（spawn）起来，
%每个人名字的后面会打印出自己的pid号，如果运行正确，刘备和孙权的pid会不断的上升，如图\ref{fig:p3-sanguo}所示。

%\begin{figure}[!htbp]
%  \centering
%  \includegraphics[width=0.8\textwidth]{p3-sanguo}
%  \caption{三国杀测试\label{fig:p3-sanguo}}
%\end{figure}

%当然，上述的描述只是对这个复杂的测试的一个好懂的解释，上图也仅为示意图，\textbf{{请同学们通过阅读测试代码具体了解测试的内容和逻辑。}}

%\subsubsection{注意事项}

%\begin{enumerate}
%\item  本次实验我们实现的\textbf{{进程通信函数属于用户态的库函数}}，但是需要系统调用使用同步原语去保证。
%\item  本次实验涉及到的内容比较多，需要用到之前实现的很多系统调用，如果同学们在测试的时候出现bug，请认真查漏补缺和助教老师沟通和交流。
%\end{enumerate}

\section{多核CPU的支持}

% 在之前的实验中，我们使用的一直是单核的NutShell处理器，这次我们为大家准备新的双核NutShell处理器，首先需要将SD卡中的镜像替换为我们新发放的双核NutShell镜像。
现在我们需要切换到双核处理器，把两个核的定时器中断都打开，让两个核能同时处理不同的进程，充分利用多核处理器的优势。
显著的优势往往伴随着巨大的挑战，在实现双核的过程中，大家需要思考许多问题：如何启动双核？
开启从核的定时器中断之后需要怎样对就绪队列进行管理？是设计成双核共用一个就绪队列还是采用每个核各自管理各自的队列？
此外还需要思考双核的例外处理是否共用一套代码，如果共用一套例外处理的代码，那么当两个处理器核同时陷入内核时就需要保证只能有一个核能对内核进行访问，此时需要思考应该采用什么机制来对内核进行保护。
除此之外，双核操作系统的设计还需要考虑进程间通信的问题。因此，想要实现双核的操作系统，有很多设计都需要重新考虑。

\subsection{多核的启动}
% 首先让我们切换到双核的Rocket处理器。
% 切换的方法是把开发板上的sw1开关拨到里侧，即开发板下侧并排的两个拨动开关里面靠近电源线的那一个。
% 拨到里侧之后把开发板重新上电，再启动就可以看到类似NutShell的大写ROCKET标志。这时就加载了双核的Rocket处理器。
% 注意这是要使用loadbootm命令代替loadboot命令加载内核，切换到了双核处理器之后不允许使用loadboot命令了。
\textbf{QEMU}：通过 \texttt{make debug-smp}来启动双核的debug窗口，用 \texttt{make run-smp} 在QEMU上运行双核，注意需要使用\texttt{loadbootm}才能加载QEMU双核。

\textbf{开发板}：在上电看到Nutshell的大写logo之后，通过\texttt{loadboot}启动单核，\texttt{loadbootm}启动双核。


两个处理器核心都包含完整的一套寄存器（通用寄存器及特权寄存器）以及一级cache。
对于双核实验来说，最需要弄清楚的事情是我们如何从主核控制从核执行代码。
不同的体系结构略有差别，但最核心的一点是相通的，就是利用中断机制。
在前面的实验中我们直观地理解了，中断可以使处理器核跳转到某个指定的地址。
因此，让从核执行代码的方式也是利用中断的这个特性。我们只需要让从核触发中断，自然可以让从核执行代码（中断处理函数就是我们的代码，只要能执行起来，后面都由我们控制）。
那么怎么产生中断呢？对于多核系统，有一种特殊的中断叫做核间中断 (Inter-Processor Interrupt, IPI)。核间中断就是从一个核心发往另一个核心的中断。

对于RISC-V处理器来说，有一个专门的 \texttt{send\_ipi(const unsigned long *hart\_mask)} 可以用于触发核间中断。
如果不指定\texttt{hart\_mask}的话，这个函数会给所有的核心发一个软件中断 (software interrupt)，这个函数我们已经提供给大家。

\begin{note}
\texttt{mask}在同学们未来的计算机学习历程中，很可能会常常出现。请同学们尝试理解此处\texttt{hart\_mask}的含义，并试图了解该使用何值作为参数。
\end{note}

另外，RISC-V处理器核一启动其实两个核心就都自动起来了，会自动都跳到boot loader开始执行（先后顺序不一定，甚至可能是从核先执行）。在跳入到boot loader时，\texttt{a0}寄存器会存放处理器的id号（该id号可以从\texttt{mhartid}这个CSR中读出）。各个核心的\texttt{mhartid}号不同，但肯定会有一个核心的id号为0。你可以将这个id号为0的处理器作为主核。

唤醒从核需要注意的是，主从核都需要栈空间来运行，为了避免主从核相互影响，需要为每个核设置其独立的栈空间用于启动。

本次任务需要大家实现双核启动，需要看到两个核心都进入到了内核的\texttt{main}函数中。可以在\texttt{main}函数中用\texttt{printk}打印核心id，从而判断是否两个核心都工作起来了。
% 双核启动的相关代码从bootblock.S中就需要添加。
% 因为双核改动比较大，因此我们没有打相应的补丁，而是直接放置在p3\_startfull当中，请大家注意查看并添加相应的代码

\subsection{从核的例外处理}

从核的例外处理流程和主核相同，因此，可以让主核和从核共用一套例外处理的代码。
对于主核来说，主核负责完成操作系统的所有必要的初始化工作，之后，从核只需要做必要的设置（如中断入口、定时器中断等）即可正常工作。

由于双核是同时执行的，如果两个核心同时执行内核代码，访问共享的内核变量，就可能造成同步相关的错误。
因此，需要将共享的变量或一些不能打断的过程设置为临界区，用锁保护起来。
为了便于大家快速实现多核，这里建议大家使用Linux早期的策略：实现一个大内核锁。
也就是将内核整个作为一个临界区，用一把大锁锁住。每次进入内核时立刻上锁，退出内核时解锁。

大内核锁的实现依赖于前面的实验提到过的原子指令。因为双核是同时执行的，所以为了能够实现双核间的同步，只能利用原子指令提供的原子性。
因此，需要利用前面提到的原子指令实现一个自旋锁，再将这个自选锁作为大内核锁使用。

当然，除了大内核锁以外，还有多种方案可以实现多核支持。
比如现在的多数操作系统都会细粒度地对共享的数据结构加锁。本实验不要求使用细粒度锁，但是
我们的内核中共享的数据结构并不是非常多，感兴趣的同学可以在完成双核实验后进一步完成细粒度锁并实验细粒度锁与大内核锁的区别。
当然，并不是加了锁保护了就可以直接跑起来，因为有一些变量只有一个是不行的。
比如\texttt{current\_running}，多核情况下，其实可以有多个正在运行的进程，只用一个变量显然是管理不了的。
此外，调度队列要不要每个核心各有一个？多核对于screen的输出会有何影响？这些问题都需要考虑。
有些在大内核锁的保护下，只有一份就可以了，有些也许需要多份。也有些用一份或者多份都可以。
例如，调度队列其实全局就一个是完全可以的，每个核放一个也是可以的，全凭自己根据自己代码的具体情况思考设计。

\subsection{主核和从核的工作}

在我们的代码中，开发板一上电，主核和从核就都启动起来了，那主核和从核需要做什么工作呢？这里我们需要大家仔细思考一下，提示大家注意以下几个方面：

\begin{enumerate}
    \item 内核BSS段的清空。

    \item 内核全局变量的初始化，比如系统调用表。

    \item 例外处理入口及相应的寄存器设置
\end{enumerate}


\subsection{任务3：开启双核并行运行}

% 此前我们已经将从核唤醒，但此时从核只能运行一个进程，还不能处理定时器中断，不能进行进程调度，
% 所以我们需要把从核的例外处理打开，让从核也能触发定时器中断，进行多进程调度。

\subsubsection{实验步骤}

\begin{enumerate}
    \item 启动双核，打开从核的定时器中断，让两个核都能进行定时器中断处理和进程调度。

    \item shell输入 \texttt{exec multicore} 启动multicore测试。测试效果如图 \ref{fig:smp}所示，可以看到双核相对于单核的加速比达到了1.8，在对这个实验检查时，我们希望看到单核耗时/双核耗时的比值越大越好.
\end{enumerate}

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{smp}
  \caption{双核vs单核速率对比图}
  \label{fig:smp}
\end{figure}

\subsubsection{注意事项}
\begin{enumerate}
    \item 在开启从核的例外处理之后，就可以去运行\texttt{multicore.c}中的测试用例，在这个过程中，可能会遇到单核时没有出现过的bug，这就说明之前的系统的实现有问题，在双核运行时暴露出来了，这也是实现双核的一大挑战！

    \item 在用QEMU进行双核调试时在可以使用gdb命令 \texttt{info threads} 来查看两个核当前运行到什么位置。

    \item 由于开发板的主频比较低，在做该实验时，建议将定时器中断设置为每秒100次这个量级。
\end{enumerate}

% \subsection{任务4：多核下的mailbox处理}
% 此时我们的系统以及能正常跑在双核的板子上了，我们可以实验一个双核版的进程间通信，以此来检验双核下我们的同步操作是否能正常工作。
% 另外，我们在任务2中实现的mailbox场景还比较简单，进程要么只发送mail或者只接收mail。这里我们需要实现一个三个进程互相收发的场景。
% 从这个任务开始，只有C-core的同学必须完成。

% \subsubsection{实验步骤}
% \begin{enumerate}
% \item 同学自行实现三个进程互相收发mail的功能，发送的内容依然是长度随机的字符串，且发送目标也随机。
% \item 要求三个进程行为相同，且在发送失败或接收失败的时候进入阻塞状态。但三个进程不能死锁。
% \end{enumerate}

% \subsubsection{注意事项}

% 对于实验功能要求的一点提示：由于三个进程的行为相同，且发送或接收失败时均会进入阻塞，那么如果三个进程开头都在接收，或者三个mailbox都满了但三个进程又同时在发送mail，就有可能导致三个进程同时进入阻塞状态，从而形成死锁。推荐的设计方案是，将发送和接收两个功能做成同一个系统调用，发送或接收任意一个可以进行就不会阻塞，用户程序通过返回值来判断发送和接收哪个完成了，从而重试另一个操作。这样的设计可以避免死锁的发生，当然我们也鼓励同学们使用其他的合理的设计来达到任务要求。

\subsection{任务4：shell命令taskset————将进程绑定在指定的核上}

到目前为止，我们的操作系统和应用程序都是运行在真实的物理地址上的。在Project 1当中我们就让大家实现了将用户程序加载到内存中并执行的操作。在目前的情况下我们仍然需要做到：应用知道自己会被加载到某个地址运行，而内核也确实能做到将应用加载到它指定的那个地址。这算是应用和内核在某种意义上达成的一种“协议”。为什么需要有这么苛刻的条件呢？请大家回顾一下计算机组成原理课的指令寻址方式的内容并调研位置无关代码和重定位的知识。在我们目前的代码框架中，我们通过链接器脚本和Makefile文件相互的协同来实现使每个用户程序有自己的运行空间，在这里提示大家去查看Makefile中用户程序编译的部分。

在本次实验当中我们需要并发多个代码，功能完全相同的测试程序来体现同步操作。同样的，理论上来说我们也需要为每个测试程序都编译一个可执行文件并指定一个在内存中运行的
地址空间来保证应用和内核的这种“协议”。但是这样的做法不仅浪费内存，而且显得过于“丑陋”。那在目前的机制下我们就无法解决这个问题了吗？答案是有的。在我们的本次的测试设计中我们将会加载同一个
测试程序多次。对于C-Core任务，我们要求对同一个程序的多个副本，image里只有一份代码，加载到内存中也只有一份代码。相当于多个进程同时运行在同一份处于内存中的程序映像上。共享同样的代码和一些数据，
不过拥有自己的内核栈和用户栈。这样的操作需要满足什么条件呢？首先肯定要保证运行时一个进程的数据不会被另一个进程篡改，目前需要通过特殊的代码编写手段来解决这个问题。
更多的细节还需要大家多多思考。后续为我们的操作系统添加虚存机制后，每个进程都有自己的内存空间。可以很好的实现进程之间的内存隔离，这样的问题便迎刃而解了。

在实际的系统中，有时我们需要让某个进程在特定的处理器核上执行。
例如一些情况下为了提升性能，会让线程固定在某个核心上，这样就不会由于在核间反复迁移导致无法充分利用处理器的Cache中的数据。
在本任务中，我们来实现这一功能。同时，为了能够更直观地展示该功能，需要扩展ps命令，让它能够显示每个进程允许在哪个核上执行。
对于正在运行的线程（不是ready的，而是正在running的），输出它在哪个核上运行。
测试用例在\texttt{affinity.c}中，该测试会自动启动5个子任务。子任务循环完成计算，每计算一部分会输出提示信息。

绑定处理器核通过taskset命令完成。该命令有两种形式：

\begin{description}
    \item[\texttt{taskset mask [任务名称]}] 启动任务并设置其允许运行的核为mask

    \item[\texttt{taskset -p mask pid}] 设置进程pid的允许运行的核为mask
\end{description}

mask是一个16进制数，每一位代表是否运行进程运行在该核心上。比如\texttt{0x1}代表只运行在核0上面。\texttt{0x2}代表只允许运行在核1上面。\texttt{0x3}代表允许运行在核0和核1上面。
第一种形式类似于之前实现的exec的功能，只不过可以为被启动的任务指定一个mask，来说明它被允许调度到哪个核心上。第二种形式是为已经运行的进程设置mask的。

这里需要大家额外支持一个功能，就是在一个任务通过\texttt{sys\_exec}启动子任务时，如果没有通过显式的指定mask，则自动继承父任务的mask。

\subsubsection{实验步骤}
\begin{enumerate}
    \item 实现taskset命令。

    \item 运行给定的测试用例，效果如图\ref{fig:taskset}所示。
    测试方式是先用taskset让affinity任务启动，mask设置为0x1，也就是只允许在第一个核心上面运行。
    之后ps看到它以及它开启的子任务确实是都在第一个核心上运行的。之后选择一个affinity开启的子任务，用taskset将mask设置为0x2，
    之后再ps，看到该任务在第二个核心上运行，同时该任务运行的速度比其他的任务都快（过几轮循环后应该会明显快于其他任务）。

    \item 此外可以看到打印的过程中，access会随机打印出1到7之间的数值，这是一个绝对地址的访问，用于检测大家是否按照内核与应用程序的“协议”将应用程序加载到对应位置，并且注意到五个任务的auipc输出都是一样的，标志着他们在同一个地址空间上运行，共享代码空间。
\end{enumerate}

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=0.5\textwidth]{taskset}
  \caption{绑核效果图}
  \label{fig:taskset}
\end{figure}


\subsection{任务5：多核mailbox防止死锁}


在前面的实验中，我们已经实现了基于 mailbox 的进程间通信机制，能够支持不同进程之间进行消息发送与接收。然而，当多个进程（或核）在并发访问多个 mailbox 时，如果资源分配和同步控制不当，系统可能陷入死锁（deadlock）。  
\subsubsection{实验描述}
考虑如下场景：
\begin{enumerate}
    \item 进程 A：先从 \texttt{mbox2} 读取数据，再向 \texttt{mbox1} 发送数据；  
    \item 进程 B：先从 \texttt{mbox1} 读取数据，再向 \texttt{mbox2} 发送数据;
\end{enumerate}

若在某一时刻，\texttt{mbox1} 和 \texttt{mbox2} 都已满，而 A、B 同时尝试执行 \texttt{send} 操作，则两个进程都将阻塞，形成典型的循环等待死锁。在实际系统中，这种死锁常由资源请求顺序不一致或同步策略设计不当引起。

为避免该问题，同学们需要为每个进程设计一个简单的线程机制。例如，在进程 A 中创建两个线程：一个专门负责从 \texttt{mbox2} 接收数据，另一个专门负责向 \texttt{mbox1} 发送数据。通过将发送与接收操作分离，使得每个线程在执行时仅请求单一类型的资源，从而避免同时“占有并等待”多个资源。该设计破坏了死锁产生的必要条件之一——占有且等待，从而实现系统的无死锁运行。


\subsubsection{实验要求}  
\begin{enumerate}
  \item \textbf{死锁复现：}  
  编写测试程序，按照上述场景复现死锁现象，在程序初始化时，将两个mailbox都填满，再进行对mailbox发送和读取数据。要求在多核环境下运行，验证当两个 mailbox 均满时，且A 和 B 进程同时尝试\texttt{send}操作时，A 和 B 进程均阻塞无法继续执行。
  
  \item \textbf{线程机制设计：}  
  实现一个最小可行的线程框架，包括线程创建、切换、同步与退出等功能。可参考 \texttt{pthread} 的接口形式（如 \texttt{thread\_create}、\texttt{thread\_join}），但允许根据系统现有支持自行简化实现。 
  
  \item \textbf{死锁规避实现：}  
  基于所实现的线程机制，修改进程 A 与 B 的通信逻辑，将发送与接收操作分配给不同线程，通过异步协作避免资源循环等待。  
  要求能够稳定运行，不出现阻塞现象。
  

\end{enumerate}


% \subsection{任务5：细粒度锁内核实现}

% 早期的 Linux 内核采用大内核锁来实现同步。这使得双核访问不同资源的内核路径不能同步进行，造成了不必要的竞争和锁的争用，降低了系统的并发性能。相比之下细粒度锁能够减少锁的争用、拥有更好的局部性、更高的并发性和更精确的同步。因此，Linux 内核在 2.6版本之后便引入了细粒度锁，使得内核对不同的资源使用不同的锁，提高了系统的并发性能。并且，随着内核的不断发展，细粒度锁的应用也在逐步的扩展和优化，以适应不同的硬件应用和需求。

% 在本次的实验中，随着双核功能的实现，我们也要求大家实现细粒度的内核锁，为内核中不同内核资源的争用分配不同的内核锁，从而使得两个核运行的进程可以更好的并行。我们希望大家自行思考需要锁互斥保护的资源，例如调度队列，屏幕 buffer等等。为了让大家直观的感受到细粒度锁的优势，要求大家分别准备大内核锁和细粒度锁实现的两份内核镜像，因此大家在编写细粒度锁时，可以先备份好当前的大粒度锁内核实现。按照如下要求测试：

% \begin{enumerate}
% %\item 启动两个进程mbox\_server和mbox\_client，发送和接收mail。两个进程会不断进行系统调用。其中要求mbox\_server进程打印传输mail的速度，即每秒接收多少个mail。此时所有mail大小需要设置成相同的。这些修改需要同学们自己在测试程序上修改。
% \item 启动两个进程consumer和producer，进行生产和消费，功能与任务2中类似，但是生产和消费每次都只进行一个单位。两个进程会不断进行系统调用，其中要求consumer进程打印消费的速度，即每秒消费多少个商品。
% \item 再启动一个进程fly，运行飞机。
% %\item 对比启动fly进程与否时，mail接收速度的变化。由于fly进程的干扰，打开fly进程时，mail接收的速度会下降。
% \item 对比启动fly进程与否时，consumer的消费速度变化。由于fly进程的干扰，打开fly进程时，消费速度会下降。
% %\item 在使用细粒度锁的情况下，由于fly和mail使用完全不同的内核资源，打开fly之后速度的下降不能超过一半。
% \item 在使用细粒度锁的情况下，由于fly和producer使用完全不同的内核资源，打开fly之后速度的下降不能超过一半。另由于原本的生产消费程序也会进行打印，请减少打印频率，以避免因打印与fly的冲突导致速度上不去。

% \end{enumerate}
% 分别在大内核锁和细粒度锁的内核实现中使用命令 exec final-test 启动测试，注意在运行该测试时不要有其他的测试干扰。记录下相应的 ticks 数。如果大家实现正确，在细粒度锁实现下，分别绑定在主核和从核的两次 fine-grained-lock 所花费的 ticks 数之比应当接近于 2 ：1；而大内核锁实现下两次 fine-grained-lock 所花费的 ticks 数之比将会达到 1 : 25 左右，并且细粒度锁下双核并行测试与大内核锁下双核并行测试的ticks之比将会达到 1 : 50 左右（以上数据均为上板测试数据）。这里大家可能会好奇，为什么大内核锁下双核并行运行的性能反而弱于单核呢？这是因为在大内核锁实现的内核中，当 fly 和 fine-grained-lock 分别运行在不同的 cpu 核上时，由于 fly 不停的执行 sys\_write 系统调用打印输出。因此 fine-grained-lock 程序所在的时间片实际上很大部分消耗在了获取大内核锁上，造成了 cpu 时间片的浪费。所以在本任务中，我们也需要大家打印出来的耗时比接近上述的数字。

%\subsection{任务5：多核下的mailbox处理}

%此时我们的系统以及能正常跑在双核的板子上了，我们可以实验一个双核版的进程间通信，以此来检验双核下我们的同步操作是否能正常工作。
%另外，我们在任务2中实现的mailbox场景还比较简单，进程要么只发送mail或者只接收mail。这里我们需要实现一个三个进程互相收发的场景。

%\subsubsection{实验步骤}

%\begin{enumerate}
%    \item 同学自行实现三个进程互相收发mail的功能，发送的内容依然是长度随机的字符串，且发送目标也随机。
%    \item 要求三个进程行为相同，且在发送失败或接收失败的时候进入阻塞状态。但三个进程不能死锁。
%\end{enumerate}

%\subsubsection{注意事项}

%对于实验功能要求的一点提示：由于三个进程的行为相同，且发送或接收失败时均会进入阻塞，那么如果三个进程开头都在接收，或者三个mailbox都满了但三个进程又同时在发送mail，就有可能导致三个进程同时进入阻塞状态，从而形成死锁。推荐的设计方案是，将发送和接收两个功能做成同一个系统调用，发送或接收任意一个可以进行就不会阻塞，用户程序通过返回值来判断发送和接收哪个完成了，从而重试另一个操作。这样的设计可以避免死锁的发生，当然我们也鼓励同学们使用其他的合理的设计来达到任务要求。





\putbib[guideref]
\end{bibunit}
